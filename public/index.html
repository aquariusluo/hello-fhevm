<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Redact Local Demo</title>
    <link rel="stylesheet" href="/style.css" />
  </head>
  <body>
    <header>
      <div class="brand">
        <div class="logo"></div>
        <h1>Redact Demo</h1>
      </div>
      <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;">
        <div class="theme-toggle" id="theme-toggle">
          <div class="theme-toggle-slider">
            <span class="theme-icon">‚òÄÔ∏è</span>
          </div>
        </div>
        <select id="network-select" class="badge" style="cursor:pointer;padding:8px 16px;">
          <option value="localhost">Network: Localhost</option>
          <option value="sepolia">Network: Sepolia</option>
        </select>
        <button id="wallet-toggle-btn" class="wallet-toggle-button" title="Toggle Wallet">
          üëõ
        </button>
        <span class="sub" id="network-desc">Privacy Token Interaction on Local Hardhat Node</span>
      </div>
    </header>

    <main class="main-container">
      <div class="content-area">
      <div class="grid">
      <section class="card localhost-only">
        <h2>Account List</h2>
        <p class="sub small">Load local node accounts and fill recipient address with one click.</p>
        <div class="row">
          <button id="btn-accounts" class="primary">Load Accounts</button>
          <button id="btn-fill-mint-selected">Fill Mint to Selected</button>
          <button id="btn-fill-transfer-selected">Fill Transfer to Selected</button>
          <button id="btn-fill-mint2">Fill Mint to Account 2</button>
          <button id="btn-fill-transfer2">Fill Transfer to Account 2</button>
        </div>
        <pre id="accounts-output"></pre>
      </section>
      <section class="card localhost-only">
        <h2>Contract Address</h2>
        <p class="sub small">Read the deployed RedactedToken contract address.</p>
        <button id="btn-address" class="primary">Query RedactedToken Address</button>
        <pre id="address-output"></pre>
      </section>

      <section class="card localhost-only">
        <h2>Balance Query & Decrypt</h2>
        <p class="sub small">Select local account index for decryption to view clear balance.</p>
        <div class="row">
          <input id="balance-address" placeholder="Address (leave empty for default)" />
          <select id="balance-index-select">
            <option value="">Select Decrypt Account</option>
          </select>
          <button id="btn-balance" class="primary">Query Balance</button>
          <button id="btn-refresh-balance" style="cursor:pointer">üîÑ Refresh</button>
        </div>
        <div style="font-size:12px;color:#888;margin-top:8px">
          Last updated: <span id="last-refresh-time">Never</span>
        </div>
        <pre id="balance-output"></pre>
      </section>

      <section class="card mint-card">
        <h2>Encrypt ETH</h2>
        <p class="sub small">Deposit and encrypt your ETH to eETH for privacy in one transaction.</p>
        <div class="seg-toggle">
          <button class="seg active" id="tab-encrypt">üîí Encrypt</button>
          <button class="seg" id="tab-decrypt">üëÅÔ∏è Decrypt</button>
        </div>
        <hr class="seg-divider" />
        <div class="deposit">
          <div class="deposit-header">
            <div>
              <div class="deposit-title">You Deposit</div>
              <span id="deposit-unit">ETH</span>
              <div class="deposit-edit">
                <input id="deposit-input" type="number" min="0" step="0.000000000000000001" inputmode="decimal" placeholder="0" />
              </div>
              <div class="pill-balance muted">Balance: <span id="pill-balance">--</span></div>
            </div>
            <div class="pill">
              <span class="pill-icon">Asset</span>
              <select id="asset-select" class="pill-select">
                <option value="ETH" selected>ETH</option>
              </select>
              <button class="pill-action" id="btn-max">MAX</button>
            </div>
          </div>
          <div class="range">
            <input type="range" id="mint-range" min="0" max="100" step="1" />
            <div class="range-marks">
              <span>0%</span><span>25%</span><span>50%</span><span>75%</span><span>100%</span>
            </div>
          </div>
        </div>
        <div class="steps">
          <div class="steps-title">Encryption steps:</div>
          <div class="steps-items">
            <div class="step"><span class="dot" id="step-deploy-dot"></span><span>Deploy</span></div>
            <div class="step"><span class="dot" id="step-approve-dot"></span><span>Approve</span></div>
            <div class="step"><span class="dot" id="step-encrypt-dot"></span><span>Encrypt</span></div>
          </div>
          <div class="steps-error" id="steps-error" style="display:none"></div>
        </div>
        <div class="cta">
          <button class="cta-primary" id="btn-encrypt-cta">ENCRYPT</button>
          <div class="cta-caption" id="cta-caption">Encrypt 0 ETH into eETH</div>
        </div>
        <pre id="mint-output"></pre>
      </section>

      <section class="card localhost-only">
        <h2>Private Transfer</h2>
        <p class="sub small">Transfer encrypted ETH to other accounts privately.</p>
        <div class="row">
          <input id="transfer-to" placeholder="Recipient address (e.g. Account 2)" />
          <input id="transfer-value" placeholder="Amount in ETH (e.g. 0.01)" />
          <button id="btn-transfer" class="primary">Transfer</button>
        </div>
        <pre id="transfer-output"></pre>
      </section>

      <section class="card localhost-only">
        <h2>Withdraw ETH</h2>
        <p class="sub small">Withdraw clear balance back to your wallet as native ETH.</p>
        <div class="row">
          <input id="withdraw-value" placeholder="Amount in ETH (e.g. 0.01)" />
          <button id="btn-withdraw" class="primary">Withdraw ETH</button>
        </div>
        <pre id="withdraw-output"></pre>
      </section>
      </div>
      </div>
    </main>

    <!-- Wallet Backdrop -->
    <div class="wallet-backdrop" id="wallet-backdrop"></div>

    <!-- Loading Modal -->
    <div class="loading-modal" id="loading-modal">
      <div class="loading-content">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading balance...</div>
        <div class="loading-subtext">Please wait while we fetch your data</div>
      </div>
    </div>

    <!-- Wallet Panel (Fixed Overlay) -->
    <aside class="wallet-panel collapsed" id="wallet-panel">
        <!-- Theme Toggle - Top Left -->
        <div class="wallet-theme-toggle">
          <button class="theme-btn light-mode" id="wallet-theme-light">‚òÄÔ∏è</button>
          <button class="theme-btn dark-mode active" id="wallet-theme-dark">üåô</button>
        </div>

        <!-- Wallet Address Card -->
        <div class="wallet-address-card">
          <span class="wallet-icon">üëõ</span>
          <span class="address-short" id="wallet-address-display">0x4D47...41fa1</span>
          <button class="copy-btn" id="copy-address" title="Copy address">üìã</button>
          <button class="close-btn" title="Close">‚úï</button>
        </div>

        <!-- Balance Display -->
        <div class="wallet-balance">
          <div class="balance-amount" id="wallet-total-balance">
            <span class="balance-loading">Loading...</span>
          </div>
        </div>

        <!-- Network Selector -->
        <div class="wallet-network-selector">
          <div class="network-icon">
            <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath fill='%23627EEA' d='M12 0L5 12.5l7 4 7-4L12 0z'/%3E%3Cpath fill='%238A9FFF' d='M5 12.5L12 24l7-11.5-7 4-7-4z'/%3E%3C/svg%3E" alt="ETH" style="width: 20px; height: 20px;" />
          </div>
          <span class="network-name">Ethereum</span>
          <span class="dropdown-arrow">‚ñº</span>
        </div>

        <!-- Action Buttons -->
        <div class="wallet-actions">
          <button class="wallet-action-btn send-btn">
            <span class="action-icon">‚Üó</span> SEND
          </button>
          <button class="wallet-action-btn receive-btn">
            <span class="action-icon">‚Üô</span> RECEIVE
          </button>
        </div>

        <!-- Tabs -->
        <div class="wallet-tabs">
          <button class="wallet-tab active" id="tab-tokens">Tokens</button>
          <button class="wallet-tab" id="tab-history">History</button>
        </div>

        <!-- Balance Legend -->
        <div class="balance-legend">
          <span class="legend-label">Balance Legend:</span>
          <span class="legend-item">
            <span class="legend-dot public"></span> Public
          </span>
          <span class="legend-item">
            <span class="legend-dot claimable"></span> Claimable
          </span>
          <span class="legend-item">
            <span class="legend-dot confidential"></span> Confidential
          </span>
        </div>

        <!-- Tokens List -->
        <div class="tokens-list" id="tokens-list">
          <!-- ETH Token -->
          <div class="token-row">
            <div class="token-info">
              <div class="token-icon eth-icon">Œû</div>
              <div class="token-details">
                <div class="token-name">ETH / WETH</div>
                <div class="token-privacy">
                  <span class="privacy-icon">üëÅ</span>
                  <span class="privacy-percent" id="eth-privacy-percent">0%</span>
                </div>
              </div>
            </div>
            <div class="token-balance">
              <div class="balance-value" id="eth-balance">
                <span class="balance-loading-small">--</span>
              </div>
              <div class="balance-confidential">
                <span id="eth-confidential-percent">0%</span>
                <span class="no-view-icon">üö´</span>
              </div>
            </div>
            <div class="token-progress">
              <div class="progress-bar">
                <div class="progress-segment public" id="eth-public-bar" style="width: 0%"></div>
                <div class="progress-segment claimable" id="eth-claimable-bar" style="width: 0%"></div>
                <div class="progress-segment confidential" id="eth-confidential-bar" style="width: 0%"></div>
              </div>
            </div>
          </div>

          <!-- USDC Token (placeholder) -->
          <div class="token-row">
            <div class="token-info">
              <div class="token-icon usdc-icon">$</div>
              <div class="token-details">
                <div class="token-name">USDC</div>
                <div class="token-privacy">
                  <span class="privacy-icon">üëÅ</span>
                  <span class="privacy-percent">0%</span>
                </div>
              </div>
            </div>
            <div class="token-balance">
              <div class="balance-value">0</div>
              <div class="balance-confidential">
                <span>0%</span>
                <span class="no-view-icon">üö´</span>
              </div>
            </div>
            <div class="token-progress">
              <div class="progress-bar">
                <div class="progress-segment public" style="width: 0%"></div>
              </div>
            </div>
          </div>

          <!-- EURC Token (placeholder) -->
          <div class="token-row">
            <div class="token-info">
              <div class="token-icon eurc-icon">‚Ç¨</div>
              <div class="token-details">
                <div class="token-name">EURC</div>
                <div class="token-privacy">
                  <span class="privacy-icon">üëÅ</span>
                  <span class="privacy-percent">0%</span>
                </div>
              </div>
            </div>
            <div class="token-balance">
              <div class="balance-value">0</div>
              <div class="balance-confidential">
                <span>0%</span>
                <span class="no-view-icon">üö´</span>
              </div>
            </div>
            <div class="token-progress">
              <div class="progress-bar">
                <div class="progress-segment public" style="width: 0%"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="history-list" id="history-list" style="display: none;">
          <div class="history-empty">No transaction history</div>
        </div>
      </aside>

    <div id="toast"></div>
    <footer>
      <small>This page is for local demo only, calling Hardhat tasks to complete interactions.</small>
    </footer>

    <script>
      // Network Management
      let currentNetwork = localStorage.getItem('network') || 'localhost';

      // Force localhost for initial development
      if (currentNetwork !== 'localhost' && currentNetwork !== 'sepolia') {
        currentNetwork = 'localhost';
        localStorage.setItem('network', 'localhost');
      }

      (function initNetwork() {
        const networkSelect = document.getElementById('network-select');
        const networkDesc = document.getElementById('network-desc');

        // Set initial data-network attribute
        document.body.setAttribute('data-network', currentNetwork);

        if (networkSelect) {
          networkSelect.value = currentNetwork;
          updateNetworkDescription();

          networkSelect.addEventListener('change', () => {
            currentNetwork = networkSelect.value;
            localStorage.setItem('network', currentNetwork);
            // Update data-network attribute for CSS targeting
            document.body.setAttribute('data-network', currentNetwork);
            updateNetworkDescription();
            showToast(`Switched to ${currentNetwork === 'localhost' ? 'Localhost' : 'Sepolia Testnet'}`, 'success');
            // Reload accounts and contract info for new network
            setTimeout(() => {
              loadAccountsForNetwork();
              updateDeployStatus();
              updateApproveAndBalance();
            }, 500);
          });
        }

        function updateNetworkDescription() {
          if (networkDesc) {
            networkDesc.textContent = currentNetwork === 'localhost'
              ? 'Privacy Token Interaction on Local Hardhat Node'
              : 'Privacy Token Interaction on Ethereum Sepolia Testnet';
          }
        }
      })();

      // Blockchain event listener for balance changes
      (async function initBlockchainEventListener() {
        // Only setup event listener if browser supports it and network is available
        if (typeof window.ethereum === 'undefined') {
          console.log('No Web3 provider detected, event listeners disabled');
          return;
        }

        try {
          // Listen for new blocks - this triggers after transactions are mined
          if (window.ethereum && window.ethereum.on) {
            let blockCheckTimeout = null;

            window.ethereum.on('chainChanged', () => {
              console.log('Chain changed, clearing event listeners');
              clearTimeout(blockCheckTimeout);
            });

            // Simple block polling fallback (works without direct event support)
            let lastBlockNumber = null;
            async function checkForNewBlocks() {
              try {
                // Only check if we have a pending transaction
                if (!window.__pendingTransactionCount || window.__pendingTransactionCount === 0) {
                  return;
                }

                const response = await fetch(`/api/address?network=${currentNetwork}`);
                if (response.ok) {
                  // If API responds, a transaction might have completed
                  // Refresh balance to check
                  await updateApproveAndBalance();
                  window.__pendingTransactionCount = Math.max(0, (window.__pendingTransactionCount || 1) - 1);
                }
              } catch (e) {
                // Silently ignore errors in background polling
              }
            }

            // Check every 5 seconds when there are pending transactions
            setInterval(() => {
              if (window.__pendingTransactionCount && window.__pendingTransactionCount > 0) {
                checkForNewBlocks();
              }
            }, 5000);
          }
        } catch (error) {
          console.log('Event listener setup failed:', error.message);
        }
      })();

      // Theme Toggle
      (function initTheme() {
        const savedTheme = localStorage.getItem('theme') || 'light';
        document.documentElement.setAttribute('data-theme', savedTheme);
        updateThemeIcon(savedTheme);

        const toggle = document.getElementById('theme-toggle');
        if (toggle) {
          toggle.addEventListener('click', () => {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updateThemeIcon(newTheme);
          });
        }

        function updateThemeIcon(theme) {
          const icon = document.querySelector('.theme-icon');
          if (icon) {
            icon.textContent = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
          }
        }
      })();

      // Auto-refresh balance on page load
      window.addEventListener('load', async () => {
        // Show loading modal on page load
        showLoadingModal('Initializing...', 'Loading application and connecting to network');

        try {
          // Load all data including balance - keep modal open until everything is ready
          await Promise.all([
            loadAccountsForNetwork(),
            updateDeployStatus(),
            updateApproveAndBalance()
          ]);

          // Hide loading modal only after all data including balance is loaded
          hideLoadingModal();

          // Don't auto-open wallet - let user open it manually when needed
        } catch (e) {
          console.log('Initial load failed:', e);
          // Hide loading modal even on error
          hideLoadingModal();

          // Show user-friendly error message
          showToast('Failed to load data. Please refresh the page.', 'error');
        }
      });

      // Update last refresh timestamp
      function updateLastRefreshTime() {
        const el = document.getElementById('last-refresh-time');
        if (!el) return;
        const now = new Date();
        window.__lastRefreshTime = now;
        el.textContent = 'Just now';

        // Update relative time every 10 seconds
        clearInterval(window.__refreshTimeInterval);
        window.__refreshTimeInterval = setInterval(() => {
          if (!window.__lastRefreshTime) return;
          const secondsAgo = Math.floor((Date.now() - window.__lastRefreshTime.getTime()) / 1000);
          if (secondsAgo < 60) {
            el.textContent = `${secondsAgo} seconds ago`;
          } else {
            const minutesAgo = Math.floor(secondsAgo / 60);
            el.textContent = `${minutesAgo} minute${minutesAgo > 1 ? 's' : ''} ago`;
          }
        }, 10000);
      }

      function showToast(msg, type = '') {
        const el = document.getElementById('toast');
        if (!el) return;
        el.textContent = msg;
        el.className = type ? type : '';
        el.style.display = 'block';
        clearTimeout(window.__toastTimer);
        window.__toastTimer = setTimeout(() => {
          el.style.display = 'none';
        }, 2500);
      }

      // Loading Modal Functions
      function showLoadingModal(text = 'Loading balance...', subtext = 'Please wait while we fetch your data') {
        const modal = document.getElementById('loading-modal');
        if (modal) {
          const textEl = modal.querySelector('.loading-text');
          const subtextEl = modal.querySelector('.loading-subtext');
          if (textEl) textEl.textContent = text;
          if (subtextEl) subtextEl.textContent = subtext;
          modal.classList.add('active');
        }
      }

      function hideLoadingModal() {
        const modal = document.getElementById('loading-modal');
        if (modal) {
          modal.classList.remove('active');
        }
      }

      async function callApi(path, options = {}) {
        // Add network parameter to URL
        const separator = path.includes('?') ? '&' : '?';
        const networkParam = `${separator}network=${currentNetwork}`;
        const fullPath = path + networkParam;

        const res = await fetch(fullPath, options);
        let data;
        try {
          data = await res.json();
        } catch (e) {
          const text = await res.text();
          data = { ok: res.ok, raw: text };
        }
        // Show toast only for errors
        if (typeof data?.ok !== 'undefined') {
          if (!data.ok) {
            showToast(data.error || 'Operation failed', 'error');
          }
        } else if (!res.ok) {
          showToast('Operation failed', 'error');
        }
        return data;
      }

      function isValidAddress(addr) {
        return /^0x[a-fA-F0-9]{40}$/.test(addr || "");
      }
      function isLocalAccount(addr) {
        const acc = window.__accounts || [];
        return acc.includes(addr);
      }

      function setSelectedIndexAndAutofill(idx) {
        const acc = window.__accounts || [];
        const selected = acc[idx] || '';
        if (selected) {
          const addrInput = document.getElementById('balance-address');
          const mintTo = document.getElementById('mint-to');
          const transferTo = document.getElementById('transfer-to');
          if (addrInput) addrInput.value = selected;
          if (mintTo) mintTo.value = selected;
          if (transferTo) transferTo.value = selected;
        }
      }

      function populateAccountSelect(accounts) {
        const sel = document.getElementById('balance-index-select');
        if (!sel) return;
        sel.innerHTML = '';
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = 'Select decrypt account';
        sel.appendChild(placeholder);
        accounts.forEach((a, i) => {
          const opt = document.createElement('option');
          opt.value = String(i);
          opt.textContent = `Account ${i}: ${a}`;
          sel.appendChild(opt);
        });
        if (accounts.length > 0) {
          sel.value = '0';
          setSelectedIndexAndAutofill(0);
        }
        sel.onchange = () => {
          const v = sel.value;
          if (v === '') return;
          const idx = parseInt(v, 10);
          if (!Number.isNaN(idx)) setSelectedIndexAndAutofill(idx);
        };
      }

      document.getElementById('btn-address').onclick = async () => {
        const out = document.getElementById('address-output');
        out.textContent = 'Querying...';
        try {
          const data = await callApi('/api/address');
          if (data.ok) {
            out.textContent = `Address: ${data.address}\n\nOutput:\n${data.raw}`;
          } else {
            out.textContent = `Error: ${data.error}`;
          }
        } catch (e) {
          out.textContent = 'Request failed';
        }
      };

      document.getElementById('btn-accounts').onclick = async () => {
        await loadAccountsForNetwork();
      };

      async function loadAccountsForNetwork() {
        const out = document.getElementById('accounts-output');
        out.textContent = 'Loading...';
        try {
          const data = await callApi('/api/accounts');
          if (data.ok) {
            window.__accounts = data.accounts || [];
            out.textContent = data.accounts.map((a, i) => `Account ${i}: ${a}`).join('\n');
            populateAccountSelect(window.__accounts);
          } else {
            out.textContent = `Error: ${data.error}`;
          }
        } catch (e) {
          out.textContent = 'Request failed';
        }
      }

      document.getElementById('btn-fill-mint-selected').onclick = () => {
        const acc = window.__accounts || [];
        const sel = document.getElementById('balance-index-select');
        let idx = sel && sel.value !== '' ? parseInt(sel.value, 10) : (acc.length >= 2 ? 1 : (acc.length >= 1 ? 0 : null));
        if (idx !== null && acc[idx]) {
          document.getElementById('mint-to').value = acc[idx];
        }
      };

      document.getElementById('btn-fill-transfer-selected').onclick = () => {
        const acc = window.__accounts || [];
        const sel = document.getElementById('balance-index-select');
        let idx = sel && sel.value !== '' ? parseInt(sel.value, 10) : (acc.length >= 2 ? 1 : (acc.length >= 1 ? 0 : null));
        if (idx !== null && acc[idx]) {
          document.getElementById('transfer-to').value = acc[idx];
        }
      };

      // ‰øùÁïôË¥¶Êà∑2‰∏ÄÈîÆÂ°´ÂÖÖÁöÑÂø´Êç∑ÊåâÈíÆ
      document.getElementById('btn-fill-mint2').onclick = () => {
        const acc = window.__accounts || [];
        if (acc.length >= 2) {
          document.getElementById('mint-to').value = acc[1];
        }
      };

      document.getElementById('btn-fill-transfer2').onclick = () => {
        const acc = window.__accounts || [];
        if (acc.length >= 2) {
          document.getElementById('transfer-to').value = acc[1];
        }
      };

      document.getElementById('btn-balance').onclick = async () => {
        const out = document.getElementById('balance-output');
        const addr = document.getElementById('balance-address').value.trim();
        const sel = document.getElementById('balance-index-select');
        const idxVal = sel ? sel.value : '';
        const idx = idxVal === '' ? '0' : idxVal;

        // Show loading modal
        showLoadingModal('Loading balance...', 'Please wait while we fetch your data');
        out.textContent = 'Querying...';

        try {
          const params = new URLSearchParams();
          if (addr) params.set('address', addr);
          if (idx) params.set('fromIndex', idx);
          const q = params.toString() ? `?${params.toString()}` : '';
          const data = await callApi(`/api/balance${q}`);
          if (data.ok) {
            const walletDec = formatDec(toDecimal(data.wallet || 0));
            const clearDec = formatDec(toDecimal(data.clear));
            const enc = data.encrypted || '';
            const raw = data.raw || '';
            out.textContent = `Wallet ETH Balance: ${walletDec} ETH\n\nContract Clear Balance: ${clearDec} ETH\nContract Encrypted Balance: ${enc}\n\nRaw Output:\n${raw}`;
          } else {
            out.textContent = `Error: ${data.error}`;
          }
        } catch (e) {
          out.textContent = 'Request failed';
        } finally {
          hideLoadingModal();
        }
      };

      // Manual refresh button handler
      document.getElementById('btn-refresh-balance').onclick = async () => {
        try {
          await updateApproveAndBalance();
          updateLastRefreshTime();
          showToast('Balance refreshed', 'success');
        } catch (e) {
          showToast('Refresh failed', 'error');
        }
      };

      // Wallet Panel Interactions
      (function initWalletPanel() {
        const walletPanel = document.getElementById('wallet-panel');
        const walletToggleBtn = document.getElementById('wallet-toggle-btn');
        const walletBackdrop = document.getElementById('wallet-backdrop');
        const closeBtn = document.querySelector('.close-btn');

        // Toggle wallet panel
        function toggleWallet() {
          if (walletPanel) {
            const isCollapsed = walletPanel.classList.contains('collapsed');
            if (isCollapsed) {
              walletPanel.classList.remove('collapsed');
              if (walletToggleBtn) {
                walletToggleBtn.classList.add('active');
              }
              if (walletBackdrop) {
                walletBackdrop.classList.add('active');
              }
              // Save state
              localStorage.setItem('walletPanelOpen', 'true');

              // Auto-fetch balance when wallet opens
              autoFetchWalletBalance();
            } else {
              walletPanel.classList.add('collapsed');
              if (walletToggleBtn) {
                walletToggleBtn.classList.remove('active');
              }
              if (walletBackdrop) {
                walletBackdrop.classList.remove('active');
              }
              // Save state
              localStorage.setItem('walletPanelOpen', 'false');
            }
          }
        }

        // Auto-fetch balance when wallet opens
        async function autoFetchWalletBalance() {
          try {
            // Check if we have cached balance data
            const cachedWallet = window.__walletBalance;
            const cachedClear = window.__availableBalance;
            const cachedEncrypted = window.__privateBalanceEstimate;

            // If we have cached data, show it immediately
            if (cachedWallet || cachedClear || cachedEncrypted) {
              updateWalletPanel(
                cachedWallet || '0',
                cachedClear || '0',
                cachedEncrypted || '0'
              );
            } else {
              // No cached data, show loading modal
              showLoadingModal('Loading wallet balance...', 'Fetching your token balances');
            }

            // Then fetch fresh data in the background
            // Trigger a balance update if we have accounts loaded
            if (window.__accounts && window.__accounts.length > 0) {
              // Call the existing balance update function
              if (typeof updateApproveAndBalance === 'function') {
                await updateApproveAndBalance();
              }
            } else {
              // Try to load accounts first
              const data = await callApi('/api/accounts');
              if (data.ok && data.accounts) {
                window.__accounts = data.accounts || [];
                window.__accountsList = data.accounts || [];
                populateAccountSelect(window.__accounts);

                // Now fetch balance
                if (typeof updateApproveAndBalance === 'function') {
                  await updateApproveAndBalance();
                }
              }
            }
          } catch (e) {
            console.log('Auto-fetch balance failed:', e);
            // Show a friendly message if balance fetch fails
            const totalBalEl = document.getElementById('wallet-total-balance');
            if (totalBalEl && totalBalEl.textContent.includes('Loading')) {
              totalBalEl.innerHTML = '<span style="font-size: 18px; color: var(--text-muted);">Unable to load balance</span>';
            }
          } finally {
            // Always hide loading modal when done
            hideLoadingModal();
          }
        }

        // Wallet toggle button click
        if (walletToggleBtn) {
          walletToggleBtn.addEventListener('click', toggleWallet);
        }

        // Close button click
        if (closeBtn) {
          closeBtn.addEventListener('click', toggleWallet);
        }

        // Backdrop click to close
        if (walletBackdrop) {
          walletBackdrop.addEventListener('click', toggleWallet);
        }

        // Restore wallet state from localStorage
        const savedState = localStorage.getItem('walletPanelOpen');
        if (savedState === 'true' && walletPanel) {
          walletPanel.classList.remove('collapsed');
          if (walletToggleBtn) {
            walletToggleBtn.classList.add('active');
          }
          if (walletBackdrop) {
            walletBackdrop.classList.add('active');
          }
          // Auto-fetch balance on page load if wallet is open
          setTimeout(() => {
            autoFetchWalletBalance();
          }, 500);
        }

        // Wallet theme toggle
        const lightBtn = document.getElementById('wallet-theme-light');
        const darkBtn = document.getElementById('wallet-theme-dark');

        if (lightBtn && darkBtn) {
          // Sync with main theme
          const currentTheme = document.documentElement.getAttribute('data-theme');
          if (currentTheme === 'dark') {
            darkBtn.classList.add('active');
            lightBtn.classList.remove('active');
          } else {
            lightBtn.classList.add('active');
            darkBtn.classList.remove('active');
          }

          lightBtn.addEventListener('click', () => {
            document.documentElement.setAttribute('data-theme', 'light');
            localStorage.setItem('theme', 'light');
            lightBtn.classList.add('active');
            darkBtn.classList.remove('active');
            updateThemeIcon('light');
          });

          darkBtn.addEventListener('click', () => {
            document.documentElement.setAttribute('data-theme', 'dark');
            localStorage.setItem('theme', 'dark');
            darkBtn.classList.add('active');
            lightBtn.classList.remove('active');
            updateThemeIcon('dark');
          });
        }

        function updateThemeIcon(theme) {
          const icon = document.querySelector('.theme-icon');
          if (icon) {
            icon.textContent = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
          }
        }

        // Tab switching
        const tabTokens = document.getElementById('tab-tokens');
        const tabHistory = document.getElementById('tab-history');
        const tokensList = document.getElementById('tokens-list');
        const historyList = document.getElementById('history-list');

        if (tabTokens && tabHistory && tokensList && historyList) {
          tabTokens.addEventListener('click', () => {
            tabTokens.classList.add('active');
            tabHistory.classList.remove('active');
            tokensList.style.display = 'flex';
            historyList.style.display = 'none';
          });

          tabHistory.addEventListener('click', () => {
            tabHistory.classList.add('active');
            tabTokens.classList.remove('active');
            historyList.style.display = 'flex';
            tokensList.style.display = 'none';
          });
        }

        // Copy address functionality
        const copyBtn = document.getElementById('copy-address');
        if (copyBtn) {
          copyBtn.addEventListener('click', () => {
            const addrDisplay = document.getElementById('wallet-address-display');
            const fullAddr = addrDisplay?.dataset?.fullAddress || addrDisplay?.textContent;
            if (fullAddr) {
              navigator.clipboard.writeText(fullAddr).then(() => {
                showToast('Address copied to clipboard', 'success');
              }).catch(() => {
                showToast('Failed to copy address', 'error');
              });
            }
          });
        }

        // Send/Receive button actions
        const sendBtn = document.querySelector('.send-btn');
        const receiveBtn = document.querySelector('.receive-btn');

        if (sendBtn) {
          sendBtn.addEventListener('click', () => {
            // Scroll to transfer section by finding the h2 element with "Private Transfer" text
            const headers = document.querySelectorAll('h2');
            let transferSection = null;
            headers.forEach(h => {
              if (h.textContent.includes('Private Transfer')) {
                transferSection = h.parentElement;
              }
            });
            if (transferSection) {
              transferSection.scrollIntoView({ behavior: 'smooth' });
            } else {
              // Fallback: just show a message
              showToast('Use the Private Transfer section to send tokens', 'success');
            }
          });
        }

        if (receiveBtn) {
          receiveBtn.addEventListener('click', () => {
            const addrDisplay = document.getElementById('wallet-address-display');
            const fullAddr = addrDisplay?.dataset?.fullAddress || addrDisplay?.textContent;
            if (fullAddr) {
              navigator.clipboard.writeText(fullAddr).then(() => {
                showToast('Your address copied! Share it to receive tokens', 'success');
              }).catch(() => {
                showToast('Failed to copy address', 'error');
              });
            }
          });
        }
      })();

      // Local persistence: save/read private balance estimate by account index to avoid loss after refresh
      function getSelectedIndex(){
        const sel = document.getElementById('balance-index-select');
        const idxVal = sel ? sel.value : '';
        return idxVal === '' ? '0' : idxVal;
      }
      function storageKeyForEstimate(index){
        return `__privateBalanceEstimate:${index}`;
      }
      function readPrivateEstimate(){
        try {
          const idx = getSelectedIndex();
          const raw = localStorage.getItem(storageKeyForEstimate(idx));
          if (raw !== null) {
            window.__privateBalanceEstimate = raw;
            return;
          }
        } catch(e) { /* Ignore local storage errors */ }
        if (typeof window.__privateBalanceEstimate === 'undefined') {
          window.__privateBalanceEstimate = '0';
        }
      }
      function writePrivateEstimate(){
        try {
          const idx = getSelectedIndex();
          const val = window.__privateBalanceEstimate || '0';
          localStorage.setItem(storageKeyForEstimate(idx), val);
        } catch(e) { /* Ignore local storage errors */ }
      }
      // 18 decimal places for ETH (wei) conversion utilities
      const DECIMALS = 18;
      const UNIT_SCALE = 1_000_000_000_000_000_000; // 1e18 wei = 1 ETH
      // Use pure string/integer for decimal conversion to avoid floating point errors
      function sanitizeDecimalInput(str){
        let s = String(str || '0').trim();
        if (!s) return '0';
        // Keep only digits and one decimal point
        s = s.replace(/[^\d.]/g, '');
        const firstDot = s.indexOf('.');
        if (firstDot !== -1) {
          s = s.slice(0, firstDot + 1) + s.slice(firstDot + 1).replace(/\./g, '');
        }
        let [whole, frac = ''] = s.split('.');
        whole = (whole || '').replace(/^0+(?=\d)/, ''); // Remove extra leading zeros
        frac = (frac || '').slice(0, DECIMALS); // Max 18 decimal places
        if (!frac) return whole || '0';
        return `${whole || '0'}.${frac}`;
      }
      function decToWei(str){
        const s = sanitizeDecimalInput(str);
        const parts = s.split('.');
        const whole = parts[0] || '0';
        const frac = parts[1] || '';
        const wholeInt = BigInt(whole || 0);
        const fracInt = BigInt(frac ? frac.padEnd(DECIMALS, '0') : 0);
        return wholeInt * BigInt(UNIT_SCALE) + fracInt;
      }
      function weiToDecString(wei){
        let w = BigInt(wei || 0);
        if (w <= 0n) return '0';
        const whole = w / BigInt(UNIT_SCALE);
        const frac = w % BigInt(UNIT_SCALE);
        let fracStr = String(frac).padStart(DECIMALS, '0').replace(/0+$/, '');
        return fracStr ? `${whole}.${fracStr}` : String(whole);
      }
      function toWei(dec){
        return decToWei(dec);
      }
      function toDecimal(wei){
        return weiToDecString(wei);
      }
      function formatDec(dec){
        // Normalize display: max 18 decimal places, remove trailing zeros
        const s = sanitizeDecimalInput(dec);
        if (!s.includes('.')) return s;
        const [w, f] = s.split('.');
        const tf = (f || '').replace(/0+$/, '');
        return tf ? `${w}.${tf}` : w;
      }
      // Disable MAX button when no balance (Encrypt refs wallet balance, Decrypt refs private balance estimate)
      function updateMaxDisabled(){
        const btnMax = document.getElementById('btn-max');
        if (!btnMax) return;
        const isDecrypt = document.getElementById('tab-decrypt')?.classList.contains('active');
        const base = isDecrypt
          ? (window.__privateBalanceEstimate || '0')
          : (window.__walletBalance || '0');
        btnMax.disabled = !(BigInt(base) > 0n);
      }
      // Segment button interaction: Encrypt / Decrypt mode toggle
      (function bindSegTabs(){
        const btnE = document.getElementById('tab-encrypt');
        const btnD = document.getElementById('tab-decrypt');
        const cta = document.getElementById('btn-encrypt-cta');
        const ctaCaption = document.getElementById('cta-caption');
        const unitEl = document.getElementById('deposit-unit');
        const pillBalEl = document.getElementById('pill-balance');
        if (!btnE || !btnD) return;
        btnE.onclick = () => {
          btnE.classList.add('active');
          btnD.classList.remove('active');
          if (cta) { cta.disabled = false; cta.textContent = 'ENCRYPT'; }
          if (ctaCaption) {
            const amountShown = document.getElementById('deposit-amount')?.textContent || '0';
            const unit = unitEl?.textContent || 'ETH';
            ctaCaption.textContent = `Encrypt ${amountShown} ${unit} into e${unit}`;
          }
          // ÂàáÊç¢‰∏∫Âä†ÂØÜÊ®°ÂºèÊó∂ÊòæÁ§∫Èí±ÂåÖ‰ΩôÈ¢ù
          if (pillBalEl) {
            const micro = window.__walletBalance || '0';
            pillBalEl.textContent = formatDec(toDecimal(micro));
          }
          // Update MAX button availability based on current balance
          updateMaxDisabled();
          // Switch to Encrypt mode: reset input and display to 0 (integer) and set slider to 0%
          try {
            const range = document.getElementById('mint-range');
            const amountEl = document.getElementById('deposit-amount');
            const depositInput = document.getElementById('deposit-input');
            const unit = unitEl?.textContent || 'RT';
            const zeroVal = 0;
            if (amountEl) amountEl.textContent = String(zeroVal);
            if (depositInput) depositInput.value = String(zeroVal);
            if (ctaCaption) ctaCaption.textContent = `Encrypt ${String(zeroVal)} ${unit} into e${unit}`;
            if (range) {
              range.value = '0';
              range.style.setProperty('--val', `0%`);
              // ÂàáÊç¢Ê®°ÂºèÊó∂ËßÜ‰∏∫Á≥ªÁªüËÆæÁΩÆÔºåÈáçÁΩÆ touched
              try { range.dataset.touched = 'false'; } catch(e) { /* ÂøΩÁï• */ }
            }
          } catch(e) { /* ÂøΩÁï•ÂàáÊç¢ÊòæÁ§∫ÈîôËØØ */ }
          // Ê†πÊçÆÂΩìÂâçÊªëÊùÜÈáçÊñ∞ÂêåÊ≠•‰∏ÄÊ¨°Ôºà‰ªÖÂΩìÁî®Êà∑ÊõæÊìç‰ΩúËøáÊªëÊùÜÊó∂Ôºâ
          const range = document.getElementById('mint-range');
          if (range && range.dataset && range.dataset.touched === 'true') {
            range.dispatchEvent(new Event('input'));
          }
        };
        btnD.onclick = () => {
          btnD.classList.add('active');
          btnE.classList.remove('active');
          if (cta) { cta.disabled = false; cta.textContent = 'DECRYPT'; }
          if (ctaCaption) {
            const amountShown = document.getElementById('deposit-amount')?.textContent || '0';
            const unit = unitEl?.textContent || 'ETH';
            ctaCaption.textContent = `Withdraw ${amountShown} e${unit} as ${unit}`;
          }
          // ÂàáÊç¢‰∏∫Ëß£ÂØÜÊ®°ÂºèÊó∂ÊòæÁ§∫‰º∞ÁÆóÁöÑÂä†ÂØÜ‰ΩôÈ¢ùÔºàÊú¨Âú∞‰º∞ÂÄºÔºâ
          if (pillBalEl) {
            const micro = window.__privateBalanceEstimate || '0';
            pillBalEl.textContent = formatDec(toDecimal(micro));
          }
          // Ê†πÊçÆÂΩìÂâç‰ΩôÈ¢ùÁ¶ÅÁî®ÊàñÂêØÁî® MAX
          updateMaxDisabled();
          // ÂàáÊç¢Âà∞ Decrypt Êó∂ÔºöÂ∞ÜËæìÂÖ•‰∏éÊòæÁ§∫ÈáçÁΩÆ‰∏∫ 0ÔºàÊï¥Êï∞ÔºâÔºåÂπ∂Â∞ÜÊªëÊùÜÁΩÆ‰∏∫ 0%
          try {
            const range = document.getElementById('mint-range');
            const amountEl = document.getElementById('deposit-amount');
            const depositInput = document.getElementById('deposit-input');
            const unit = unitEl?.textContent || 'RT';
            const zeroVal = 0;
            if (amountEl) amountEl.textContent = String(zeroVal);
            if (depositInput) depositInput.value = String(zeroVal);
            if (ctaCaption) ctaCaption.textContent = `Withdraw ${String(zeroVal)} e${unit} as ${unit}`;
            if (range) {
              range.value = '0';
              range.style.setProperty('--val', `0%`);
              // ÂàáÊç¢Ê®°ÂºèÊó∂ËßÜ‰∏∫Á≥ªÁªüËÆæÁΩÆÔºåÈáçÁΩÆ touched
              try { range.dataset.touched = 'false'; } catch(e) { /* ÂøΩÁï• */ }
            }
          } catch(e) { /* ÂøΩÁï•ÂàáÊç¢ÊòæÁ§∫ÈîôËØØ */ }
          // Ê†πÊçÆÂΩìÂâçÊªëÊùÜÈáçÊñ∞ÂêåÊ≠•‰∏ÄÊ¨°Ôºà‰ªÖÂΩìÁî®Êà∑ÊõæÊìç‰ΩúËøáÊªëÊùÜÊó∂Ôºâ
          const range = document.getElementById('mint-range');
          if (range && range.dataset && range.dataset.touched === 'true') {
            range.dispatchEvent(new Event('input'));
          }
        };
      })();

      // ÊªëÊùÜ‰∏é MAX ‰∫§‰∫íÔºöËÅîÂä®Èì∏Â∏ÅÊï∞Èáè‰∏éÊòæÁ§∫
      (function initDepositUI(){
        const range = document.getElementById('mint-range');
        const amountEl = document.getElementById('deposit-amount');
        const btnMax = document.getElementById('btn-max');
        const ctaCaption = document.getElementById('cta-caption');
        const unitEl = document.getElementById('deposit-unit');
        const depositInput = document.getElementById('deposit-input');
        // ÂàùÂßãÊ†πÊçÆ‰ΩôÈ¢ùÁä∂ÊÄÅÁ¶ÅÁî® MAX
        updateMaxDisabled();
        function sync(val){
          const percent = parseFloat(val || '0');
          const isDecrypt = document.getElementById('tab-decrypt')?.classList.contains('active');
          const balanceMicro = isDecrypt
            ? BigInt(window.__privateBalanceEstimate || '0')
            : BigInt(window.__walletBalance || '0');
          const amtMicro = balanceMicro > 0n ? (balanceMicro * BigInt(Math.floor(percent * 100)) / 10000n) : 0n;
          const shownDec = toDecimal(amtMicro);
          if (amountEl) amountEl.textContent = formatDec(shownDec);
          if (depositInput) depositInput.value = formatDec(shownDec);
          if (ctaCaption && unitEl) {
            const unit = unitEl.textContent || 'RT';
            ctaCaption.textContent = isDecrypt
              ? `Withdraw ${formatDec(shownDec)} e${unit} as ${unit}`
              : `Encrypt ${formatDec(shownDec)} ${unit} into e${unit}`;
          }
          if (range) {
            const pct = Math.max(0, Math.min(100, percent));
            range.style.setProperty('--val', `${pct}%`);
          }
        }
        function setByInput(v){
          const rawDec = sanitizeDecimalInput(v || '0');
          const isDecrypt = document.getElementById('tab-decrypt')?.classList.contains('active');
          const baseMicro = isDecrypt
            ? BigInt(window.__privateBalanceEstimate || '0')
            : BigInt(window.__walletBalance || '0');
          const rawMicro = BigInt(toWei(rawDec));
          const clampedMicro = baseMicro > 0n ? (rawMicro < baseMicro ? rawMicro : baseMicro) : rawMicro;
          const shownDec = toDecimal(clampedMicro);
          const percent = baseMicro > 0n ? Number(clampedMicro * 10000n / baseMicro) / 100 : 0;
          if (range) {
            range.value = String(Math.max(0, Math.min(100, percent)));
            // ÂêåÊ≠•ÊªëÊùÜÂ∫ïËâ≤
            const pct = Math.max(0, Math.min(100, percent));
            range.style.setProperty('--val', `${pct}%`);
          }
          // Keep the user's input value exactly as typed (don't overwrite with calculated value)
          if (amountEl) amountEl.textContent = formatDec(rawDec);
          if (ctaCaption && unitEl) {
            const unit = unitEl.textContent || 'RT';
            ctaCaption.textContent = isDecrypt
              ? `Withdraw ${formatDec(rawDec)} e${unit} as ${unit}`
              : `Encrypt ${formatDec(rawDec)} ${unit} into e${unit}`;
          }
        }
        if (range){
          range.addEventListener('input', () => {
            // Ê†áËÆ∞ÊªëÊùÜÂ∑≤Ë¢´Áî®Êà∑Êìç‰ΩúÔºåÈÅøÂÖçÂêéÁª≠Ëá™Âä®Âà∑Êñ∞Ë¶ÜÁõñ‰∏∫ 0
            try { range.dataset.touched = 'true'; } catch(e) { /* ÂøΩÁï• */ }
            sync(range.value);
          });
        }
        if (depositInput){
          depositInput.addEventListener('input', () => {
            // Ê†áËÆ∞ÊªëÊùÜ/ËæìÂÖ•Ê°ÜÂ∑≤Ë¢´Áî®Êà∑Êìç‰ΩúÔºåÈÅøÂÖçÂêéÁª≠Ëá™Âä®Âà∑Êñ∞Ë¶ÜÁõñ‰∏∫ 0
            try {
              const range = document.getElementById('mint-range');
              if (range && range.dataset) range.dataset.touched = 'true';
            } catch(e) { /* ÂøΩÁï• */ }
            setByInput(depositInput.value);
          });
          // Remove blur event handler - keep user's exact input value
        }
        if (btnMax){
          btnMax.addEventListener('click', () => {
            const isDecrypt = document.getElementById('tab-decrypt')?.classList.contains('active');
            const base = isDecrypt
              ? BigInt(window.__privateBalanceEstimate || '0')
              : BigInt(window.__walletBalance || '0');
            const targetPct = base > 0n ? '100' : '0';
            if (range) range.value = targetPct;
            sync(targetPct);
          });
        }
        // ÂàùÂßãÂêåÊ≠•
        if (range) sync(range.value || '0');
      })();

      // ÈÉ®ÁΩ≤‰∏éÊâπÂáÜÊ≠•È™§Áä∂ÊÄÅËÅîÂä®Ôºå‰ª•Âèä‰ΩôÈ¢ùËØªÂèñ
      function setDotState(id, state){
        const el = document.getElementById(id);
        if (!el) return;
        el.classList.remove('active','done','error');
        if (state) el.classList.add(state);
        // ÂêåÊ≠•Ê≠•È™§ÂÆπÂô®Á±ªÔºåÁî®‰∫éÈ©±Âä®ËøûÁ∫øÂä®ÁîªÔºàÁÅ∞->ÁªøÔºâ
        const step = el.closest('.step');
        if (step){
          step.classList.remove('active','done','error');
          if (state) step.classList.add(state);
        }
      }
      function setStepsError(msg){
        const el = document.getElementById('steps-error');
        if (!el) return;
        if (msg){ el.style.display='block'; el.textContent = msg; }
        else { el.style.display='none'; el.textContent = ''; }
      }
      async function updateDeployStatus(){
        try {
          setDotState('step-deploy-dot','active');
          const data = await callApi('/api/address');
          if (data.ok && data.address){
            setDotState('step-deploy-dot','done');
            setStepsError('');
          } else {
            setDotState('step-deploy-dot','error');
            setStepsError('Contract address not obtained, Deploy not completed');
          }
        } catch(e){
          setDotState('step-deploy-dot','error');
          setStepsError('Failed to query contract address');
        }
      }
      async function updateApproveAndBalance(){
        try {
          setDotState('step-approve-dot','active');
          const addr = document.getElementById('balance-address').value.trim();
          const sel = document.getElementById('balance-index-select');
          const idxVal = sel ? sel.value : '';
          const idx = idxVal === '' ? '0' : idxVal;
          const params = new URLSearchParams();
          if (addr) params.set('address', addr);
          if (idx) params.set('fromIndex', idx);
          const q = params.toString() ? `?${params.toString()}` : '';
          const data = await callApi(`/api/balance${q}`);
          if (data.ok){
            const clearBal = data.clear || '0';
            const walletBal = data.wallet || '0';
            const decryptedBal = data.decrypted || '0';
            window.__availableBalance = clearBal;
            window.__walletBalance = walletBal;
            // Use actual decrypted balance from blockchain instead of local estimate
            window.__privateBalanceEstimate = decryptedBal;
            // Also update localStorage with the real value
            writePrivateEstimate();
            const balEl = document.getElementById('pill-balance');
            if (balEl) {
              const isDecrypt = document.getElementById('tab-decrypt')?.classList.contains('active');
              // In Encrypt mode, show wallet balance (since we deposit from wallet now)
              // In Decrypt mode, show estimated private balance
              const micro = isDecrypt ? (window.__privateBalanceEstimate || '0') : walletBal;
              balEl.textContent = formatDec(toDecimal(micro));
            }
            setDotState('step-approve-dot','done');
            setStepsError('');
            // Update slider display based on balance - but don't overwrite user input
            const range = document.getElementById('mint-range');
            if (range) {
              const unitEl = document.getElementById('deposit-unit');
              const assetSel = document.getElementById('asset-select');
              if (unitEl && assetSel) unitEl.textContent = assetSel.value;
            }
            // Ê†πÊçÆ‰ΩôÈ¢ùÁä∂ÊÄÅÊõ¥Êñ∞ MAX ÊåâÈíÆÂèØÁî®ÊÄß
            updateMaxDisabled();
            // Update last refresh timestamp
            updateLastRefreshTime();
            // Update wallet panel display
            updateWalletPanel(walletBal, clearBal, decryptedBal);
          } else {
            setDotState('step-approve-dot','error');
            setStepsError(data.error || 'Approve stage failed');
          }
        } catch(e){
          setDotState('step-approve-dot','error');
          setStepsError('Failed to read balance and approve');
        }
      }

      // Update wallet panel with balance data
      function updateWalletPanel(walletBal, clearBal, encryptedBal) {
        try {
          // Convert BigInt strings to numbers for calculations
          const wallet = BigInt(walletBal || '0');
          const clear = BigInt(clearBal || '0');
          const encrypted = BigInt(encryptedBal || '0');

          // Total balance = wallet (public) + clear (claimable) + encrypted (confidential)
          const total = wallet + clear + encrypted;

          // Update total balance display
          const totalBalEl = document.getElementById('wallet-total-balance');
          if (totalBalEl) {
            const balanceText = `${formatDec(toDecimal(total))} ETH`;
            // Remove loading state and show balance
            totalBalEl.innerHTML = balanceText;
            totalBalEl.classList.add('loaded');
          }

          // Update ETH balance
          const ethBalEl = document.getElementById('eth-balance');
          if (ethBalEl) {
            const balanceText = formatDec(toDecimal(total));
            ethBalEl.innerHTML = balanceText;
          }

          // Calculate percentages for progress bars
          const totalNum = Number(total);
          let publicPercent = 0;
          let claimablePercent = 0;
          let confidentialPercent = 0;

          if (totalNum > 0) {
            publicPercent = (Number(wallet) / totalNum) * 100;
            claimablePercent = (Number(clear) / totalNum) * 100;
            confidentialPercent = (Number(encrypted) / totalNum) * 100;
          }

          // Update progress bars
          const publicBar = document.getElementById('eth-public-bar');
          const claimableBar = document.getElementById('eth-claimable-bar');
          const confidentialBar = document.getElementById('eth-confidential-bar');

          if (publicBar) publicBar.style.width = `${publicPercent}%`;
          if (claimableBar) claimableBar.style.width = `${claimablePercent}%`;
          if (confidentialBar) confidentialBar.style.width = `${confidentialPercent}%`;

          // Update privacy percentage (public visibility)
          const privacyPercentEl = document.getElementById('eth-privacy-percent');
          if (privacyPercentEl) {
            privacyPercentEl.textContent = `${publicPercent.toFixed(2)}%`;
          }

          // Update confidential percentage (hidden amount)
          const confidentialPercentEl = document.getElementById('eth-confidential-percent');
          if (confidentialPercentEl) {
            confidentialPercentEl.textContent = `${confidentialPercent.toFixed(2)}%`;
          }

          // Update wallet address display
          const accounts = window.__accountsList || [];
          const sel = document.getElementById('balance-index-select');
          const idx = sel ? parseInt(sel.value || '0') : 0;
          if (accounts[idx]) {
            const addr = accounts[idx];
            const shortAddr = `${addr.slice(0, 6)}...${addr.slice(-6)}`;
            const addrDisplay = document.getElementById('wallet-address-display');
            if (addrDisplay) {
              addrDisplay.textContent = shortAddr;
              addrDisplay.dataset.fullAddress = addr;
            }
          }
        } catch (e) {
          console.error('Failed to update wallet panel:', e);
          // Show error state
          const totalBalEl = document.getElementById('wallet-total-balance');
          if (totalBalEl) {
            totalBalEl.innerHTML = '<span style="font-size: 18px; color: var(--error);">Error loading balance</span>';
          }
        }
      }

      // Refresh approve and balance when account selection changes
      (function bindSelectRefresh(){
        const sel = document.getElementById('balance-index-select');
        if (!sel) return;
        const origOnChange = sel.onchange;
        sel.onchange = (ev)=>{
          if (typeof origOnChange === 'function') origOnChange(ev);
          // ÂàáÊç¢Ë¥¶Êà∑Êó∂ËØªÂèñËØ•Ë¥¶Êà∑ÁöÑÊú¨Âú∞‰º∞ÂÄº
          readPrivateEstimate();
          updateApproveAndBalance();
          updateMaxDisabled();
        };
      })();

      // ËµÑ‰∫ßÂàáÊç¢ÔºõÂΩìÂâçÂêéÁ´Ø‰ªÖÊîØÊåÅ RTÔºåETH ‰Ωú‰∏∫Âç†‰Ωç
      (function bindAssetSelect(){
        const assetSel = document.getElementById('asset-select');
        if (!assetSel) return;
        const unitEl = document.getElementById('deposit-unit');
        assetSel.addEventListener('change', ()=>{
          if (unitEl) unitEl.textContent = assetSel.value;
          // ÂàáÊç¢ÂêéÈáçÊñ∞ÂêåÊ≠•‰ΩôÈ¢ùÊòæÁ§∫
          updateApproveAndBalance();
        });
      })();

      // Bind unified CTA: call Deposit+Encrypt or Decrypt based on segment
      (function bindUnifiedCTA(){
        const cta = document.getElementById('btn-encrypt-cta');
        if (!cta) return;

        // Track if operation is in progress
        let operationInProgress = false;

        cta.onclick = async () => {
          // Prevent multiple clicks during operation
          if (operationInProgress) {
            showToast('Operation in progress, please wait...', 'error');
            return;
          }

          const out = document.getElementById('mint-output');
          if (!out) return;
          const encryptDot = document.getElementById('step-encrypt-dot');
          const fromSel = document.getElementById('balance-index-select');
          const fromIndex = fromSel ? fromSel.value : '0';
          const isDecrypt = document.getElementById('tab-decrypt')?.classList.contains('active');

          if (isDecrypt) {
            // First check if this is the initial decrypt click
            if (cta && cta.textContent === 'DECRYPT') {
              // Change button to WITHDRAW and return (don't execute yet)
              cta.textContent = 'WITHDRAW';
              out.textContent = 'Click WITHDRAW to complete the operation and convert encrypted balance to native ETH.';
              return;
            }

            // Disable button and start operation
            operationInProgress = true;
            cta.disabled = true;
            cta.style.opacity = '0.6';
            cta.style.cursor = 'not-allowed';

            // Withdraw mode: call /api/decrypt then /api/withdraw-eth to convert encrypted balance to native ETH
            out.textContent = 'Submitting withdraw...';
            if (encryptDot) {
              encryptDot.classList.remove('done','error');
              encryptDot.classList.add('active');
            }
            try {
              const rawInput = document.getElementById('deposit-input')?.value || '0';
              const dec = sanitizeDecimalInput(rawInput);
              const numWei = toWei(dec);
              if (!(numWei > 0n)) {
                out.textContent = 'Error: Withdraw amount must be positive ETH';
                if (encryptDot) {
                  encryptDot.classList.remove('active');
                  encryptDot.classList.add('error');
                }
                // Re-enable button
                operationInProgress = false;
                cta.disabled = false;
                cta.style.opacity = '1';
                cta.style.cursor = 'pointer';
                return;
              }
              const privateBalEst = BigInt(window.__privateBalanceEstimate || '0');
              if (numWei > privateBalEst) {
                out.textContent = `Error: Insufficient encrypted balance. You have ${toDecimal(privateBalEst)} eETH, but trying to withdraw ${dec} eETH.`;
                if (encryptDot) {
                  encryptDot.classList.remove('active');
                  encryptDot.classList.add('error');
                }
                // Re-enable button
                operationInProgress = false;
                cta.disabled = false;
                cta.style.opacity = '1';
                cta.style.cursor = 'pointer';
                return;
              }

              // Step 1: Decrypt encrypted balance to clear balance
              out.textContent = 'Step 1/2: Decrypting...';
              window.__pendingTransactionCount = (window.__pendingTransactionCount || 0) + 1;
              const decryptData = await callApi('/api/decrypt', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ value: String(numWei), fromIndex })
              });

              if (!decryptData.ok) {
                out.textContent = `Error in decrypt step: ${decryptData.error}`;
                if (encryptDot) {
                  encryptDot.classList.remove('active','done');
                  encryptDot.classList.add('error');
                }
                // Re-enable button
                operationInProgress = false;
                cta.disabled = false;
                cta.style.opacity = '1';
                cta.style.cursor = 'pointer';
                return;
              }

              // Step 2: Withdraw clear balance as native ETH
              out.textContent = 'Step 2/2: Withdrawing ETH...';
              window.__pendingTransactionCount = (window.__pendingTransactionCount || 0) + 1;
              const withdrawData = await callApi('/api/withdraw-eth', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ value: dec, fromIndex })
              });

              if (withdrawData.ok) {
                out.textContent = `Withdraw succeeded!\n\nDecrypt tx: ${decryptData.tx}\nWithdraw tx: ${withdrawData.tx}\n\nTotal amount: ${formatDec(dec)} ETH\n\nDecrypt output:\n${decryptData.raw}\n\nWithdraw output:\n${withdrawData.raw}`;
                if (encryptDot) {
                  encryptDot.classList.remove('active','error');
                  encryptDot.classList.add('done');
                }
                // Reset button back to DECRYPT
                if (cta) cta.textContent = 'DECRYPT';
                // Update private balance estimate
                if (numWei > 0n) {
                  const currentBal = BigInt(window.__privateBalanceEstimate || '0');
                  window.__privateBalanceEstimate = String(currentBal - numWei);
                  writePrivateEstimate();
                }
                updateApproveAndBalance();
                updateMaxDisabled();

                // Clear input after successful withdraw
                const depositInput = document.getElementById('deposit-input');
                if (depositInput) {
                  depositInput.value = '';
                }
                const mintRange = document.getElementById('mint-range');
                if (mintRange) {
                  mintRange.value = '0';
                  mintRange.style.setProperty('--val', '0%');
                }
                const depositAmount = document.getElementById('deposit-amount');
                if (depositAmount) {
                  depositAmount.textContent = '0';
                }
              } else {
                out.textContent = `Decrypt succeeded but withdraw failed.\n\nDecrypt tx: ${decryptData.tx}\nWithdraw error: ${withdrawData.error}\n\nNote: ${formatDec(dec)} ETH is now in your clear balance. You can withdraw it manually from the "Withdraw ETH" section below.`;
                if (encryptDot) {
                  encryptDot.classList.remove('active','done');
                  encryptDot.classList.add('error');
                }
                // Reset button back to DECRYPT even on error
                if (cta) cta.textContent = 'DECRYPT';
              }
            } catch (e) {
              out.textContent = 'Request failed: ' + e.message;
              if (encryptDot) {
                encryptDot.classList.remove('active','done');
                encryptDot.classList.add('error');
              }
              // Reset button back to DECRYPT on error
              if (cta) cta.textContent = 'DECRYPT';
            } finally {
              // Always re-enable button when operation completes
              operationInProgress = false;
              cta.disabled = false;
              cta.style.opacity = '1';
              cta.style.cursor = 'pointer';
            }
          } else {
            // Disable button and start operation
            operationInProgress = true;
            cta.disabled = true;
            cta.style.opacity = '0.6';
            cta.style.cursor = 'not-allowed';

            // Encrypt mode: call new combined /api/deposit-and-encrypt
            out.textContent = 'Submitting deposit and encrypt...';
            if (encryptDot) {
              encryptDot.classList.remove('done','error');
              encryptDot.classList.add('active');
            }
            try {
              const rawInput = document.getElementById('deposit-input')?.value || '0';
              const dec = sanitizeDecimalInput(rawInput);
              const numWei = toWei(dec);
              if (!(numWei > 0n)) {
                out.textContent = 'Error: Deposit amount must be positive ETH';
                if (encryptDot) {
                  encryptDot.classList.remove('active');
                  encryptDot.classList.add('error');
                }
                // Re-enable button
                operationInProgress = false;
                cta.disabled = false;
                cta.style.opacity = '1';
                cta.style.cursor = 'pointer';
                return;
              }
              const walletBal = BigInt(window.__walletBalance || '0');
              if (numWei > walletBal) {
                out.textContent = `Error: Insufficient wallet balance. You have ${toDecimal(walletBal)} ETH, but trying to deposit ${dec} ETH.`;
                if (encryptDot) {
                  encryptDot.classList.remove('active');
                  encryptDot.classList.add('error');
                }
                // Re-enable button
                operationInProgress = false;
                cta.disabled = false;
                cta.style.opacity = '1';
                cta.style.cursor = 'pointer';
                return;
              }
              window.__pendingTransactionCount = (window.__pendingTransactionCount || 0) + 1;
              const data = await callApi('/api/deposit-and-encrypt', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ value: dec, fromIndex })
              });
              if (data.ok) {
                out.textContent = `Deposit and encrypt succeeded, tx: ${data.tx}\n\nOutput:\n${data.raw}`;
                if (encryptDot) {
                  encryptDot.classList.remove('active','error');
                  encryptDot.classList.add('done');
                }
                // Update private balance estimate
                if (numWei > 0n) {
                  const currentBal = BigInt(window.__privateBalanceEstimate || '0');
                  window.__privateBalanceEstimate = String(currentBal + numWei);
                  writePrivateEstimate();
                }
                updateApproveAndBalance();
                updateMaxDisabled();

                // Clear input after successful encrypt
                const depositInput = document.getElementById('deposit-input');
                if (depositInput) {
                  depositInput.value = '';
                }
                const mintRange = document.getElementById('mint-range');
                if (mintRange) {
                  mintRange.value = '0';
                  mintRange.style.setProperty('--val', '0%');
                }
                const depositAmount = document.getElementById('deposit-amount');
                if (depositAmount) {
                  depositAmount.textContent = '0';
                }
              } else {
                out.textContent = `Error: ${data.error}`;
                if (encryptDot) {
                  encryptDot.classList.remove('active','done');
                  encryptDot.classList.add('error');
                }
              }
            } catch (e) {
              out.textContent = 'Request failed';
              if (encryptDot) {
                encryptDot.classList.remove('active','done');
                encryptDot.classList.add('error');
              }
            } finally {
              // Always re-enable button when operation completes
              operationInProgress = false;
              cta.disabled = false;
              cta.style.opacity = '1';
              cta.style.cursor = 'pointer';
            }
          }
        };
      })();

      document.getElementById('btn-transfer').onclick = async () => {
        const btn = document.getElementById('btn-transfer');
        const out = document.getElementById('transfer-output');

        // Disable button during operation
        if (btn.disabled) {
          showToast('Transfer in progress, please wait...', 'error');
          return;
        }
        btn.disabled = true;
        btn.style.opacity = '0.6';
        btn.style.cursor = 'not-allowed';

        try {
          const to = document.getElementById('transfer-to').value.trim();
          const value = document.getElementById('transfer-value').value.trim();
          const sel = document.getElementById('balance-index-select');
          const idxVal = sel ? sel.value : '';
          const fromIndex = idxVal === '' ? '0' : idxVal;
          out.textContent = 'Submitting...';
          const encryptDot = document.getElementById('step-encrypt-dot');
          if (encryptDot) {
            encryptDot.classList.remove('done','error');
            encryptDot.classList.add('active');
          }
          // Frontend validation: address format, is local account, valid amount, index range
          if (!isValidAddress(to)) {
            out.textContent = 'Error: Invalid recipient address, please enter an Ethereum address like 0x...';
            return;
          }
          if (!isLocalAccount(to)) {
            out.textContent = 'Error: Recipient address not in local account list, may cause encryption verification failure. Please "Load Accounts" first and select a local account.';
            return;
          }
          const dec = sanitizeDecimalInput(value);
          const numWei = toWei(dec);
          if (!(numWei > 0n)) {
            out.textContent = 'Error: Amount must be positive ETH (e.g. 0.01)';
            return;
          }
          // Check uint128 limit (2^128 - 1 wei ‚âà 340 undecillion ETH - effectively unlimited for practical use)
          const UINT128_MAX = 340282366920938463463374607431768211455n;
          if (numWei > UINT128_MAX) {
            const maxEth = formatDec(toDecimal(String(UINT128_MAX)));
            out.textContent = `Error: Amount exceeds uint128 maximum. Maximum is ${maxEth} ETH per transaction`;
            return;
          }
          const acc = window.__accounts || [];
          const idx = parseInt(fromIndex, 10);
          if (!Number.isInteger(idx) || idx < 0 || idx >= acc.length) {
            out.textContent = 'Error: Please select a valid transaction account index (dropdown)';
            return;
          }
          window.__pendingTransactionCount = (window.__pendingTransactionCount || 0) + 1;
          const data = await callApi('/api/transfer', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ to, value: String(numWei), fromIndex })
          });
            if (data.ok) {
              const decimalShown = formatDec(toDecimal(String(numWei)));
              out.textContent = `Transfer succeeded, tx: ${data.tx}\n\nTransfer amount: ${decimalShown} ETH\nWei amount: ${String(numWei)}\nOutput:\n${data.raw}`;
              if (encryptDot) {
                encryptDot.classList.remove('active','error');
                encryptDot.classList.add('done');
              }
              // Estimate: deduct from local estimate when current selected account's private balance is transferred out
              const currentIdx = (document.getElementById('balance-index-select')?.value || '0');
              if (numWei > 0n && String(fromIndex) === String(currentIdx)) {
                const currentBal = BigInt(window.__privateBalanceEstimate || '0');
                window.__privateBalanceEstimate = String(currentBal > numWei ? currentBal - numWei : 0n);
                // Write to local persistence
                writePrivateEstimate();
                updateApproveAndBalance();
                updateMaxDisabled();
              }

              // Clear transfer inputs after successful transfer
              const transferToInput = document.getElementById('transfer-to');
              const transferValueInput = document.getElementById('transfer-value');
              if (transferToInput) {
                transferToInput.value = '';
              }
              if (transferValueInput) {
                transferValueInput.value = '';
              }
            } else {
              out.textContent = `Error: ${data.error}`;
              if (encryptDot) {
                encryptDot.classList.remove('active','done');
              encryptDot.classList.add('error');
            }
          }
        } catch (e) {
          out.textContent = 'Request failed';
          const encryptDot = document.getElementById('step-encrypt-dot');
          if (encryptDot) {
            encryptDot.classList.remove('active','done');
            encryptDot.classList.add('error');
          }
        } finally {
          // Re-enable button
          btn.disabled = false;
          btn.style.opacity = '1';
          btn.style.cursor = 'pointer';
        }
      };

      document.getElementById('btn-withdraw').onclick = async () => {
        const btn = document.getElementById('btn-withdraw');
        const out = document.getElementById('withdraw-output');

        // Disable button during operation
        if (btn.disabled) {
          showToast('Withdrawal in progress, please wait...', 'error');
          return;
        }
        btn.disabled = true;
        btn.style.opacity = '0.6';
        btn.style.cursor = 'not-allowed';

        try {
          const value = document.getElementById('withdraw-value').value.trim();
          const sel = document.getElementById('balance-index-select');
          const idxVal = sel ? sel.value : '';
          const fromIndex = idxVal === '' ? '0' : idxVal;
          out.textContent = 'Submitting...';
          // Validate ETH amount
          const dec = sanitizeDecimalInput(value);
          const numWei = toWei(dec);
          if (!(numWei > 0n)) {
            out.textContent = 'Error: Amount must be positive ETH (e.g. 0.01)';
            return;
          }
          // Check uint128 limit (2^128 - 1 wei ‚âà 340 undecillion ETH - effectively unlimited for practical use)
          const UINT128_MAX = 340282366920938463463374607431768211455n;
          if (numWei > UINT128_MAX) {
            const maxEth = formatDec(toDecimal(String(UINT128_MAX)));
            out.textContent = `Error: Amount exceeds uint128 maximum. Maximum is ${maxEth} ETH per transaction`;
            return;
          }
          const acc = window.__accounts || [];
          const idx = parseInt(fromIndex, 10);
          if (!Number.isInteger(idx) || idx < 0 || idx >= acc.length) {
            out.textContent = 'Error: Please select a valid transaction account index (dropdown)';
            return;
          }
          const data = await callApi('/api/withdraw-eth', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ value: dec, fromIndex })
          });
          if (data.ok) {
            out.textContent = `ETH withdrawal succeeded, tx: ${data.tx}\n\nOutput:\n${data.raw}`;
            // Refresh balance after successful withdrawal
            try {
              await updateApproveAndBalance();
              updateMaxDisabled();
              // Reset withdraw input after successful withdrawal
              const withdrawValueEl = document.getElementById('withdraw-value');
              if (withdrawValueEl) withdrawValueEl.value = '0';
            } catch (e) { /* Ignore refresh errors, keep original message */ }
          } else {
            out.textContent = `Error: ${data.error}`;
          }
        } catch (e) {
          out.textContent = 'Request failed';
        } finally {
          // Re-enable button
          btn.disabled = false;
          btn.style.opacity = '1';
          btn.style.cursor = 'pointer';
        }
      };
    </script>
  </body>
  </html>