<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Redact Local Demo</title>
    <link rel="stylesheet" href="/style.css" />
  </head>
  <body>
    <header>
      <div class="brand">
        <div class="logo"></div>
        <h1>Redact Demo</h1>
      </div>
      <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;">
        <div class="theme-toggle" id="theme-toggle">
          <div class="theme-toggle-slider">
            <span class="theme-icon">‚òÄÔ∏è</span>
          </div>
        </div>
        <select id="network-select" class="badge" style="cursor:pointer;padding:8px 16px;">
          <option value="localhost">Network: Localhost</option>
          <option value="sepolia">Network: Sepolia</option>
        </select>
        <span class="sub" id="network-desc">Privacy Token Interaction on Local Hardhat Node</span>
      </div>
    </header>

    <main>
      <div class="grid">
      <section class="card">
        <h2>Account List</h2>
        <p class="sub small">Load local node accounts and fill recipient address with one click.</p>
        <div class="row">
          <button id="btn-accounts" class="primary">Load Accounts</button>
          <button id="btn-fill-mint-selected">Fill Mint to Selected</button>
          <button id="btn-fill-transfer-selected">Fill Transfer to Selected</button>
          <button id="btn-fill-mint2">Fill Mint to Account 2</button>
          <button id="btn-fill-transfer2">Fill Transfer to Account 2</button>
        </div>
        <pre id="accounts-output"></pre>
      </section>
      <section class="card">
        <h2>Contract Address</h2>
        <p class="sub small">Read the deployed RedactedToken contract address.</p>
        <button id="btn-address" class="primary">Query RedactedToken Address</button>
        <pre id="address-output"></pre>
      </section>

      <section class="card">
        <h2>Balance Query & Decrypt</h2>
        <p class="sub small">Select local account index for decryption to view clear balance.</p>
        <div class="row">
          <input id="balance-address" placeholder="Address (leave empty for default)" />
          <select id="balance-index-select">
            <option value="">Select Decrypt Account</option>
          </select>
          <button id="btn-balance" class="primary">Query Balance</button>
        </div>
        <pre id="balance-output"></pre>
      </section>

      <section class="card mint-card">
        <h2>Encrypt ETH</h2>
        <p class="sub small">Deposit and encrypt your ETH to eETH for privacy in one transaction.</p>
        <div class="seg-toggle">
          <button class="seg active" id="tab-encrypt">üîí Encrypt</button>
          <button class="seg" id="tab-decrypt">üëÅÔ∏è Decrypt</button>
        </div>
        <hr class="seg-divider" />
        <div class="deposit">
          <div class="deposit-header">
            <div>
              <div class="deposit-title">You Deposit</div>
              <span id="deposit-unit">ETH</span>
              <div class="deposit-edit">
                <input id="deposit-input" type="number" min="0" step="0.000000000000000001" inputmode="decimal" placeholder="Enter amount in ETH" />
              </div>
              <div class="pill-balance muted">Balance: <span id="pill-balance">--</span></div>
            </div>
            <div class="pill">
              <span class="pill-icon">Asset</span>
              <select id="asset-select" class="pill-select">
                <option value="ETH" selected>ETH</option>
              </select>
              <button class="pill-action" id="btn-max">MAX</button>
            </div>
          </div>
          <div class="range">
            <input type="range" id="mint-range" min="0" max="100" step="1" />
            <div class="range-marks">
              <span>0%</span><span>25%</span><span>50%</span><span>75%</span><span>100%</span>
            </div>
          </div>
        </div>
        <div class="steps">
          <div class="steps-title">Encryption steps:</div>
          <div class="steps-items">
            <div class="step"><span class="dot" id="step-deploy-dot"></span><span>Deploy</span></div>
            <div class="step"><span class="dot" id="step-approve-dot"></span><span>Approve</span></div>
            <div class="step"><span class="dot" id="step-encrypt-dot"></span><span>Encrypt</span></div>
          </div>
          <div class="steps-error" id="steps-error" style="display:none"></div>
        </div>
        <div class="cta">
          <button class="cta-primary" id="btn-encrypt-cta">ENCRYPT</button>
          <div class="cta-caption" id="cta-caption">Encrypt 0 ETH into eETH</div>
        </div>
        <pre id="mint-output"></pre>
      </section>

      <section class="card">
        <h2>Private Transfer</h2>
        <p class="sub small">Transfer encrypted ETH to other accounts privately.</p>
        <div class="row">
          <input id="transfer-to" placeholder="Recipient address (e.g. Account 2)" />
          <input id="transfer-value" placeholder="Amount in ETH (e.g. 0.01)" />
          <button id="btn-transfer" class="primary">Transfer</button>
        </div>
        <pre id="transfer-output"></pre>
      </section>

      <section class="card">
        <h2>Withdraw ETH</h2>
        <p class="sub small">Withdraw clear balance back to your wallet as native ETH.</p>
        <div class="row">
          <input id="withdraw-value" placeholder="Amount in ETH (e.g. 0.01)" />
          <button id="btn-withdraw" class="primary">Withdraw ETH</button>
        </div>
        <pre id="withdraw-output"></pre>
      </section>
      </div>
    </main>

    <div id="toast"></div>
    <footer>
      <small>This page is for local demo only, calling Hardhat tasks to complete interactions.</small>
    </footer>

    <script>
      // Network Management
      let currentNetwork = localStorage.getItem('network') || 'localhost';

      (function initNetwork() {
        const networkSelect = document.getElementById('network-select');
        const networkDesc = document.getElementById('network-desc');

        if (networkSelect) {
          networkSelect.value = currentNetwork;
          updateNetworkDescription();

          networkSelect.addEventListener('change', () => {
            currentNetwork = networkSelect.value;
            localStorage.setItem('network', currentNetwork);
            updateNetworkDescription();
            showToast(`Switched to ${currentNetwork === 'localhost' ? 'Localhost' : 'Sepolia Testnet'}`, 'success');
            // Reload accounts and contract info for new network
            setTimeout(() => {
              loadAccountsForNetwork();
              updateDeployStatus();
              updateApproveAndBalance();
            }, 500);
          });
        }

        function updateNetworkDescription() {
          if (networkDesc) {
            networkDesc.textContent = currentNetwork === 'localhost'
              ? 'Privacy Token Interaction on Local Hardhat Node'
              : 'Privacy Token Interaction on Ethereum Sepolia Testnet';
          }
        }
      })();

      // Theme Toggle
      (function initTheme() {
        const savedTheme = localStorage.getItem('theme') || 'light';
        document.documentElement.setAttribute('data-theme', savedTheme);
        updateThemeIcon(savedTheme);

        const toggle = document.getElementById('theme-toggle');
        if (toggle) {
          toggle.addEventListener('click', () => {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updateThemeIcon(newTheme);
          });
        }

        function updateThemeIcon(theme) {
          const icon = document.querySelector('.theme-icon');
          if (icon) {
            icon.textContent = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
          }
        }
      })();

      // Auto-refresh balance on page load
      window.addEventListener('load', () => {
        setTimeout(() => {
          loadAccountsForNetwork();
          updateDeployStatus();
          updateApproveAndBalance();
        }, 1000);
      });

      // Periodic auto-refresh every 30 seconds
      setInterval(() => {
        if (currentNetwork) {
          updateApproveAndBalance().catch(() => {
            // Silently ignore errors during background refresh
          });
        }
      }, 30000);

      function showToast(msg, type = '') {
        const el = document.getElementById('toast');
        if (!el) return;
        el.textContent = msg;
        el.className = type ? type : '';
        el.style.display = 'block';
        clearTimeout(window.__toastTimer);
        window.__toastTimer = setTimeout(() => {
          el.style.display = 'none';
        }, 2500);
      }

      async function callApi(path, options = {}) {
        // Add network parameter to URL
        const separator = path.includes('?') ? '&' : '?';
        const networkParam = `${separator}network=${currentNetwork}`;
        const fullPath = path + networkParam;

        const res = await fetch(fullPath, options);
        let data;
        try {
          data = await res.json();
        } catch (e) {
          const text = await res.text();
          data = { ok: res.ok, raw: text };
        }
        if (typeof data?.ok !== 'undefined') {
          showToast(data.ok ? 'Operation succeeded' : (data.error || 'Operation failed'), data.ok ? 'success' : 'error');
        } else {
          showToast(res.ok ? 'Operation succeeded' : 'Operation failed', res.ok ? 'success' : 'error');
        }
        return data;
      }

      function isValidAddress(addr) {
        return /^0x[a-fA-F0-9]{40}$/.test(addr || "");
      }
      function isLocalAccount(addr) {
        const acc = window.__accounts || [];
        return acc.includes(addr);
      }

      function setSelectedIndexAndAutofill(idx) {
        const acc = window.__accounts || [];
        const selected = acc[idx] || '';
        if (selected) {
          const addrInput = document.getElementById('balance-address');
          const mintTo = document.getElementById('mint-to');
          const transferTo = document.getElementById('transfer-to');
          if (addrInput) addrInput.value = selected;
          if (mintTo) mintTo.value = selected;
          if (transferTo) transferTo.value = selected;
        }
      }

      function populateAccountSelect(accounts) {
        const sel = document.getElementById('balance-index-select');
        if (!sel) return;
        sel.innerHTML = '';
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = 'Select decrypt account';
        sel.appendChild(placeholder);
        accounts.forEach((a, i) => {
          const opt = document.createElement('option');
          opt.value = String(i);
          opt.textContent = `Account ${i}: ${a}`;
          sel.appendChild(opt);
        });
        if (accounts.length > 0) {
          sel.value = '0';
          setSelectedIndexAndAutofill(0);
        }
        sel.onchange = () => {
          const v = sel.value;
          if (v === '') return;
          const idx = parseInt(v, 10);
          if (!Number.isNaN(idx)) setSelectedIndexAndAutofill(idx);
        };
      }

      document.getElementById('btn-address').onclick = async () => {
        const out = document.getElementById('address-output');
        out.textContent = 'Querying...';
        try {
          const data = await callApi('/api/address');
          if (data.ok) {
            out.textContent = `Address: ${data.address}\n\nOutput:\n${data.raw}`;
          } else {
            out.textContent = `Error: ${data.error}`;
          }
        } catch (e) {
          out.textContent = 'Request failed';
        }
      };

      document.getElementById('btn-accounts').onclick = async () => {
        await loadAccountsForNetwork();
      };

      async function loadAccountsForNetwork() {
        const out = document.getElementById('accounts-output');
        out.textContent = 'Loading...';
        try {
          const data = await callApi('/api/accounts');
          if (data.ok) {
            window.__accounts = data.accounts || [];
            out.textContent = data.accounts.map((a, i) => `Account ${i}: ${a}`).join('\n');
            populateAccountSelect(window.__accounts);
          } else {
            out.textContent = `Error: ${data.error}`;
          }
        } catch (e) {
          out.textContent = 'Request failed';
        }
      }

      document.getElementById('btn-fill-mint-selected').onclick = () => {
        const acc = window.__accounts || [];
        const sel = document.getElementById('balance-index-select');
        let idx = sel && sel.value !== '' ? parseInt(sel.value, 10) : (acc.length >= 2 ? 1 : (acc.length >= 1 ? 0 : null));
        if (idx !== null && acc[idx]) {
          document.getElementById('mint-to').value = acc[idx];
        }
      };

      document.getElementById('btn-fill-transfer-selected').onclick = () => {
        const acc = window.__accounts || [];
        const sel = document.getElementById('balance-index-select');
        let idx = sel && sel.value !== '' ? parseInt(sel.value, 10) : (acc.length >= 2 ? 1 : (acc.length >= 1 ? 0 : null));
        if (idx !== null && acc[idx]) {
          document.getElementById('transfer-to').value = acc[idx];
        }
      };

      // ‰øùÁïôË¥¶Êà∑2‰∏ÄÈîÆÂ°´ÂÖÖÁöÑÂø´Êç∑ÊåâÈíÆ
      document.getElementById('btn-fill-mint2').onclick = () => {
        const acc = window.__accounts || [];
        if (acc.length >= 2) {
          document.getElementById('mint-to').value = acc[1];
        }
      };

      document.getElementById('btn-fill-transfer2').onclick = () => {
        const acc = window.__accounts || [];
        if (acc.length >= 2) {
          document.getElementById('transfer-to').value = acc[1];
        }
      };

      document.getElementById('btn-balance').onclick = async () => {
        const out = document.getElementById('balance-output');
        const addr = document.getElementById('balance-address').value.trim();
        const sel = document.getElementById('balance-index-select');
        const idxVal = sel ? sel.value : '';
        const idx = idxVal === '' ? '0' : idxVal;
        out.textContent = 'Querying...';
        try {
          const params = new URLSearchParams();
          if (addr) params.set('address', addr);
          if (idx) params.set('fromIndex', idx);
          const q = params.toString() ? `?${params.toString()}` : '';
          const data = await callApi(`/api/balance${q}`);
          if (data.ok) {
            const walletDec = formatDec(toDecimal(data.wallet || 0));
            const clearDec = formatDec(toDecimal(data.clear));
            const enc = data.encrypted || '';
            const raw = data.raw || '';
            out.textContent = `Wallet ETH Balance: ${walletDec} ETH\n\nContract Clear Balance: ${clearDec} ETH\nContract Encrypted Balance: ${enc}\n\nRaw Output:\n${raw}`;
          } else {
            out.textContent = `Error: ${data.error}`;
          }
        } catch (e) {
          out.textContent = 'Request failed';
        }
      };

      // Auto load accounts on page load
      (async function autoLoadAccounts() {
        try {
          const data = await callApi('/api/accounts');
          if (data.ok) {
            window.__accounts = data.accounts || [];
            const out = document.getElementById('accounts-output');
            if (out) out.textContent = data.accounts.map((a, i) => `Account ${i}: ${a}`).join('\n');
            populateAccountSelect(window.__accounts);
            // Try to update Deploy/Approve status
            updateDeployStatus();
            updateApproveAndBalance();
          }
        } catch (e) {
          // Ignore auto-load errors, user can click button manually
        }
      })();

      // Local persistence: save/read private balance estimate by account index to avoid loss after refresh
      function getSelectedIndex(){
        const sel = document.getElementById('balance-index-select');
        const idxVal = sel ? sel.value : '';
        return idxVal === '' ? '0' : idxVal;
      }
      function storageKeyForEstimate(index){
        return `__privateBalanceEstimate:${index}`;
      }
      function readPrivateEstimate(){
        try {
          const idx = getSelectedIndex();
          const raw = localStorage.getItem(storageKeyForEstimate(idx));
          if (raw !== null) {
            window.__privateBalanceEstimate = raw;
            return;
          }
        } catch(e) { /* Ignore local storage errors */ }
        if (typeof window.__privateBalanceEstimate === 'undefined') {
          window.__privateBalanceEstimate = '0';
        }
      }
      function writePrivateEstimate(){
        try {
          const idx = getSelectedIndex();
          const val = window.__privateBalanceEstimate || '0';
          localStorage.setItem(storageKeyForEstimate(idx), val);
        } catch(e) { /* Ignore local storage errors */ }
      }
      // 18 decimal places for ETH (wei) conversion utilities
      const DECIMALS = 18;
      const UNIT_SCALE = 1_000_000_000_000_000_000; // 1e18 wei = 1 ETH
      // Use pure string/integer for decimal conversion to avoid floating point errors
      function sanitizeDecimalInput(str){
        let s = String(str || '0').trim();
        if (!s) return '0';
        // Keep only digits and one decimal point
        s = s.replace(/[^\d.]/g, '');
        const firstDot = s.indexOf('.');
        if (firstDot !== -1) {
          s = s.slice(0, firstDot + 1) + s.slice(firstDot + 1).replace(/\./g, '');
        }
        let [whole, frac = ''] = s.split('.');
        whole = (whole || '').replace(/^0+(?=\d)/, ''); // Remove extra leading zeros
        frac = (frac || '').slice(0, DECIMALS); // Max 18 decimal places
        if (!frac) return whole || '0';
        return `${whole || '0'}.${frac}`;
      }
      function decToWei(str){
        const s = sanitizeDecimalInput(str);
        const parts = s.split('.');
        const whole = parts[0] || '0';
        const frac = parts[1] || '';
        const wholeInt = BigInt(whole || 0);
        const fracInt = BigInt(frac ? frac.padEnd(DECIMALS, '0') : 0);
        return wholeInt * BigInt(UNIT_SCALE) + fracInt;
      }
      function weiToDecString(wei){
        let w = BigInt(wei || 0);
        if (w <= 0n) return '0';
        const whole = w / BigInt(UNIT_SCALE);
        const frac = w % BigInt(UNIT_SCALE);
        let fracStr = String(frac).padStart(DECIMALS, '0').replace(/0+$/, '');
        return fracStr ? `${whole}.${fracStr}` : String(whole);
      }
      function toWei(dec){
        return decToWei(dec);
      }
      function toDecimal(wei){
        return weiToDecString(wei);
      }
      function formatDec(dec){
        // Normalize display: max 18 decimal places, remove trailing zeros
        const s = sanitizeDecimalInput(dec);
        if (!s.includes('.')) return s;
        const [w, f] = s.split('.');
        const tf = (f || '').replace(/0+$/, '');
        return tf ? `${w}.${tf}` : w;
      }
      // Disable MAX button when no balance (Encrypt refs wallet balance, Decrypt refs private balance estimate)
      function updateMaxDisabled(){
        const btnMax = document.getElementById('btn-max');
        if (!btnMax) return;
        const isDecrypt = document.getElementById('tab-decrypt')?.classList.contains('active');
        const base = isDecrypt
          ? (window.__privateBalanceEstimate || '0')
          : (window.__walletBalance || '0');
        btnMax.disabled = !(BigInt(base) > 0n);
      }
      // Segment button interaction: Encrypt / Decrypt mode toggle
      (function bindSegTabs(){
        const btnE = document.getElementById('tab-encrypt');
        const btnD = document.getElementById('tab-decrypt');
        const cta = document.getElementById('btn-encrypt-cta');
        const ctaCaption = document.getElementById('cta-caption');
        const unitEl = document.getElementById('deposit-unit');
        const pillBalEl = document.getElementById('pill-balance');
        if (!btnE || !btnD) return;
        btnE.onclick = () => {
          btnE.classList.add('active');
          btnD.classList.remove('active');
          if (cta) { cta.disabled = false; cta.textContent = 'ENCRYPT'; }
          if (ctaCaption) {
            const amountShown = document.getElementById('deposit-amount')?.textContent || '0';
            const unit = unitEl?.textContent || 'ETH';
            ctaCaption.textContent = `Encrypt ${amountShown} ${unit} into e${unit}`;
          }
          // ÂàáÊç¢‰∏∫Âä†ÂØÜÊ®°ÂºèÊó∂ÊòæÁ§∫Èí±ÂåÖ‰ΩôÈ¢ù
          if (pillBalEl) {
            const micro = window.__walletBalance || '0';
            pillBalEl.textContent = formatDec(toDecimal(micro));
          }
          // Update MAX button availability based on current balance
          updateMaxDisabled();
          // Switch to Encrypt mode: reset input and display to 0 (integer) and set slider to 0%
          try {
            const range = document.getElementById('mint-range');
            const amountEl = document.getElementById('deposit-amount');
            const depositInput = document.getElementById('deposit-input');
            const unit = unitEl?.textContent || 'RT';
            const zeroVal = 0;
            if (amountEl) amountEl.textContent = String(zeroVal);
            if (depositInput) depositInput.value = String(zeroVal);
            if (ctaCaption) ctaCaption.textContent = `Encrypt ${String(zeroVal)} ${unit} into e${unit}`;
            if (range) {
              range.value = '0';
              range.style.setProperty('--val', `0%`);
              // ÂàáÊç¢Ê®°ÂºèÊó∂ËßÜ‰∏∫Á≥ªÁªüËÆæÁΩÆÔºåÈáçÁΩÆ touched
              try { range.dataset.touched = 'false'; } catch(e) { /* ÂøΩÁï• */ }
            }
          } catch(e) { /* ÂøΩÁï•ÂàáÊç¢ÊòæÁ§∫ÈîôËØØ */ }
          // Ê†πÊçÆÂΩìÂâçÊªëÊùÜÈáçÊñ∞ÂêåÊ≠•‰∏ÄÊ¨°Ôºà‰ªÖÂΩìÁî®Êà∑ÊõæÊìç‰ΩúËøáÊªëÊùÜÊó∂Ôºâ
          const range = document.getElementById('mint-range');
          if (range && range.dataset && range.dataset.touched === 'true') {
            range.dispatchEvent(new Event('input'));
          }
        };
        btnD.onclick = () => {
          btnD.classList.add('active');
          btnE.classList.remove('active');
          if (cta) { cta.disabled = false; cta.textContent = 'DECRYPT'; }
          if (ctaCaption) {
            const amountShown = document.getElementById('deposit-amount')?.textContent || '0';
            const unit = unitEl?.textContent || 'ETH';
            ctaCaption.textContent = `Decrypt ${amountShown} e${unit} into ${unit}`;
          }
          // ÂàáÊç¢‰∏∫Ëß£ÂØÜÊ®°ÂºèÊó∂ÊòæÁ§∫‰º∞ÁÆóÁöÑÂä†ÂØÜ‰ΩôÈ¢ùÔºàÊú¨Âú∞‰º∞ÂÄºÔºâ
          if (pillBalEl) {
            const micro = window.__privateBalanceEstimate || '0';
            pillBalEl.textContent = formatDec(toDecimal(micro));
          }
          // Ê†πÊçÆÂΩìÂâç‰ΩôÈ¢ùÁ¶ÅÁî®ÊàñÂêØÁî® MAX
          updateMaxDisabled();
          // ÂàáÊç¢Âà∞ Decrypt Êó∂ÔºöÂ∞ÜËæìÂÖ•‰∏éÊòæÁ§∫ÈáçÁΩÆ‰∏∫ 0ÔºàÊï¥Êï∞ÔºâÔºåÂπ∂Â∞ÜÊªëÊùÜÁΩÆ‰∏∫ 0%
          try {
            const range = document.getElementById('mint-range');
            const amountEl = document.getElementById('deposit-amount');
            const depositInput = document.getElementById('deposit-input');
            const unit = unitEl?.textContent || 'RT';
            const zeroVal = 0;
            if (amountEl) amountEl.textContent = String(zeroVal);
            if (depositInput) depositInput.value = String(zeroVal);
            if (ctaCaption) ctaCaption.textContent = `Decrypt ${String(zeroVal)} e${unit} into ${unit}`;
            if (range) {
              range.value = '0';
              range.style.setProperty('--val', `0%`);
              // ÂàáÊç¢Ê®°ÂºèÊó∂ËßÜ‰∏∫Á≥ªÁªüËÆæÁΩÆÔºåÈáçÁΩÆ touched
              try { range.dataset.touched = 'false'; } catch(e) { /* ÂøΩÁï• */ }
            }
          } catch(e) { /* ÂøΩÁï•ÂàáÊç¢ÊòæÁ§∫ÈîôËØØ */ }
          // Ê†πÊçÆÂΩìÂâçÊªëÊùÜÈáçÊñ∞ÂêåÊ≠•‰∏ÄÊ¨°Ôºà‰ªÖÂΩìÁî®Êà∑ÊõæÊìç‰ΩúËøáÊªëÊùÜÊó∂Ôºâ
          const range = document.getElementById('mint-range');
          if (range && range.dataset && range.dataset.touched === 'true') {
            range.dispatchEvent(new Event('input'));
          }
        };
      })();

      // ÊªëÊùÜ‰∏é MAX ‰∫§‰∫íÔºöËÅîÂä®Èì∏Â∏ÅÊï∞Èáè‰∏éÊòæÁ§∫
      (function initDepositUI(){
        const range = document.getElementById('mint-range');
        const amountEl = document.getElementById('deposit-amount');
        const btnMax = document.getElementById('btn-max');
        const ctaCaption = document.getElementById('cta-caption');
        const unitEl = document.getElementById('deposit-unit');
        const depositInput = document.getElementById('deposit-input');
        // ÂàùÂßãÊ†πÊçÆ‰ΩôÈ¢ùÁä∂ÊÄÅÁ¶ÅÁî® MAX
        updateMaxDisabled();
        function sync(val){
          const percent = parseFloat(val || '0');
          const isDecrypt = document.getElementById('tab-decrypt')?.classList.contains('active');
          const balanceMicro = isDecrypt
            ? BigInt(window.__privateBalanceEstimate || '0')
            : BigInt(window.__walletBalance || '0');
          const amtMicro = balanceMicro > 0n ? (balanceMicro * BigInt(Math.floor(percent * 100)) / 10000n) : 0n;
          const shownDec = toDecimal(amtMicro);
          if (amountEl) amountEl.textContent = formatDec(shownDec);
          if (depositInput) depositInput.value = formatDec(shownDec);
          if (ctaCaption && unitEl) {
            const unit = unitEl.textContent || 'RT';
            ctaCaption.textContent = isDecrypt
              ? `Decrypt ${formatDec(shownDec)} e${unit} into ${unit}`
              : `Encrypt ${formatDec(shownDec)} ${unit} into e${unit}`;
          }
          if (range) {
            const pct = Math.max(0, Math.min(100, percent));
            range.style.setProperty('--val', `${pct}%`);
          }
        }
        function setByInput(v){
          const rawDec = sanitizeDecimalInput(v || '0');
          const isDecrypt = document.getElementById('tab-decrypt')?.classList.contains('active');
          const baseMicro = isDecrypt
            ? BigInt(window.__privateBalanceEstimate || '0')
            : BigInt(window.__walletBalance || '0');
          const rawMicro = BigInt(toWei(rawDec));
          const clampedMicro = baseMicro > 0n ? (rawMicro < baseMicro ? rawMicro : baseMicro) : 0n;
          const shownDec = toDecimal(clampedMicro);
          const percent = baseMicro > 0n ? Number(clampedMicro * 10000n / baseMicro) / 100 : 0; // Êó†‰ΩôÈ¢ùÊó∂Êåâ0%Â§ÑÁêÜ
          if (range) {
            range.value = String(Math.max(0, Math.min(100, percent)));
            // ÂêåÊ≠•ÊªëÊùÜÂ∫ïËâ≤
            const pct = Math.max(0, Math.min(100, percent));
            range.style.setProperty('--val', `${pct}%`);
          }
          // Áõ¥Êé•‰ª•ËæìÂÖ•ÁöÑÊï∞ÈáèÈ©±Âä®ÊòæÁ§∫‰∏éÊèê‰∫§ÂÄºÔºåÈÅøÂÖçË¢´ÊªëÊùÜÊÆãÁïôÁôæÂàÜÊØîÂΩ±Âìç
          if (amountEl) amountEl.textContent = formatDec(shownDec);
          if (ctaCaption && unitEl) {
            const unit = unitEl.textContent || 'RT';
            ctaCaption.textContent = isDecrypt
              ? `Decrypt ${formatDec(shownDec)} e${unit} into ${unit}`
              : `Encrypt ${formatDec(shownDec)} ${unit} into e${unit}`;
          }
        }
        if (range){
          range.addEventListener('input', () => {
            // Ê†áËÆ∞ÊªëÊùÜÂ∑≤Ë¢´Áî®Êà∑Êìç‰ΩúÔºåÈÅøÂÖçÂêéÁª≠Ëá™Âä®Âà∑Êñ∞Ë¶ÜÁõñ‰∏∫ 0
            try { range.dataset.touched = 'true'; } catch(e) { /* ÂøΩÁï• */ }
            sync(range.value);
          });
        }
        if (depositInput){
          depositInput.addEventListener('input', () => {
            // Ê†áËÆ∞ÊªëÊùÜ/ËæìÂÖ•Ê°ÜÂ∑≤Ë¢´Áî®Êà∑Êìç‰ΩúÔºåÈÅøÂÖçÂêéÁª≠Ëá™Âä®Âà∑Êñ∞Ë¶ÜÁõñ‰∏∫ 0
            try {
              const range = document.getElementById('mint-range');
              if (range && range.dataset) range.dataset.touched = 'true';
            } catch(e) { /* ÂøΩÁï• */ }
            setByInput(depositInput.value);
          });
          // Â§±ÁÑ¶Êó∂Ê†ºÂºèÂåñ‰∏∫Êï¥Êï∞ÔºåÈÅøÂÖçÁºñËæëËøáÁ®ã‰∏≠Ë¢´Âº∫Âà∂Ë°•ÈΩêÂ∞èÊï∞‰Ωç
          depositInput.addEventListener('blur', () => {
            const isDecrypt = document.getElementById('tab-decrypt')?.classList.contains('active');
            const baseMicro = isDecrypt
              ? BigInt(window.__privateBalanceEstimate || '0')
              : BigInt(window.__walletBalance || '0');
            let rawDec = sanitizeDecimalInput(depositInput.value || '0');
            const rawMicro = BigInt(toWei(rawDec));
            const clampedMicro = baseMicro > 0n ? (rawMicro < baseMicro ? rawMicro : baseMicro) : rawMicro;
            const shownDec = toDecimal(clampedMicro);
            depositInput.value = formatDec(shownDec);
          });
        }
        if (btnMax){
          btnMax.addEventListener('click', () => {
            const isDecrypt = document.getElementById('tab-decrypt')?.classList.contains('active');
            const base = isDecrypt
              ? BigInt(window.__privateBalanceEstimate || '0')
              : BigInt(window.__walletBalance || '0');
            const targetPct = base > 0n ? '100' : '0';
            if (range) range.value = targetPct;
            sync(targetPct);
          });
        }
        // ÂàùÂßãÂêåÊ≠•
        if (range) sync(range.value || '0');
      })();

      // ÈÉ®ÁΩ≤‰∏éÊâπÂáÜÊ≠•È™§Áä∂ÊÄÅËÅîÂä®Ôºå‰ª•Âèä‰ΩôÈ¢ùËØªÂèñ
      function setDotState(id, state){
        const el = document.getElementById(id);
        if (!el) return;
        el.classList.remove('active','done','error');
        if (state) el.classList.add(state);
        // ÂêåÊ≠•Ê≠•È™§ÂÆπÂô®Á±ªÔºåÁî®‰∫éÈ©±Âä®ËøûÁ∫øÂä®ÁîªÔºàÁÅ∞->ÁªøÔºâ
        const step = el.closest('.step');
        if (step){
          step.classList.remove('active','done','error');
          if (state) step.classList.add(state);
        }
      }
      function setStepsError(msg){
        const el = document.getElementById('steps-error');
        if (!el) return;
        if (msg){ el.style.display='block'; el.textContent = msg; }
        else { el.style.display='none'; el.textContent = ''; }
      }
      async function updateDeployStatus(){
        try {
          setDotState('step-deploy-dot','active');
          const data = await callApi('/api/address');
          if (data.ok && data.address){
            setDotState('step-deploy-dot','done');
            setStepsError('');
          } else {
            setDotState('step-deploy-dot','error');
            setStepsError('Contract address not obtained, Deploy not completed');
          }
        } catch(e){
          setDotState('step-deploy-dot','error');
          setStepsError('Failed to query contract address');
        }
      }
      async function updateApproveAndBalance(){
        try {
          setDotState('step-approve-dot','active');
          const addr = document.getElementById('balance-address').value.trim();
          const sel = document.getElementById('balance-index-select');
          const idxVal = sel ? sel.value : '';
          const idx = idxVal === '' ? '0' : idxVal;
          const params = new URLSearchParams();
          if (addr) params.set('address', addr);
          if (idx) params.set('fromIndex', idx);
          const q = params.toString() ? `?${params.toString()}` : '';
          const data = await callApi(`/api/balance${q}`);
          if (data.ok){
            const clearBal = data.clear || '0';
            const walletBal = data.wallet || '0';
            const decryptedBal = data.decrypted || '0';
            window.__availableBalance = clearBal;
            window.__walletBalance = walletBal;
            // Use actual decrypted balance from blockchain instead of local estimate
            window.__privateBalanceEstimate = decryptedBal;
            // Also update localStorage with the real value
            writePrivateEstimate();
            const balEl = document.getElementById('pill-balance');
            if (balEl) {
              const isDecrypt = document.getElementById('tab-decrypt')?.classList.contains('active');
              // In Encrypt mode, show wallet balance (since we deposit from wallet now)
              // In Decrypt mode, show estimated private balance
              const micro = isDecrypt ? (window.__privateBalanceEstimate || '0') : walletBal;
              balEl.textContent = formatDec(toDecimal(micro));
            }
            setDotState('step-approve-dot','done');
            setStepsError('');
            // Trigger slider sync to display based on balance ratio
            const range = document.getElementById('mint-range');
            if (range) {
              const current = range.value || '0';
              const unitEl = document.getElementById('deposit-unit');
              const assetSel = document.getElementById('asset-select');
              if (unitEl && assetSel) unitEl.textContent = assetSel.value;
            const amountEl = document.getElementById('deposit-amount');
            const depositInput = document.getElementById('deposit-input');
            const percent = parseFloat(current);
            const isDecrypt = document.getElementById('tab-decrypt')?.classList.contains('active');
            const baseMicro = isDecrypt ? BigInt(window.__privateBalanceEstimate || '0') : BigInt(walletBal);
            const amtMicro = baseMicro > 0n ? (baseMicro * BigInt(Math.floor(percent * 100)) / 10000n) : 0n;
            const shownDec = toDecimal(amtMicro);
              // ‰ªÖÂΩìÁî®Êà∑Êìç‰ΩúËøáÊªëÊùÜ/ËæìÂÖ•Ê°ÜÊó∂ÊâçÂêåÊ≠•ÔºåÈÅøÂÖçËá™Âä®Âà∑Êñ∞ÊääÊï∞ÂÄºÊîπÊàê 0
              const touched = !!(range && range.dataset && range.dataset.touched === 'true');
              // ÈÅøÂÖçÂú®Áî®Êà∑Ê≠£Âú®ÁºñËæëÊó∂Ë¶ÜÁõñËæìÂÖ•Ê°ÜÁöÑÊï∞ÂÄº
              const isEditing = document.activeElement && document.activeElement.id === 'deposit-input';
              if (touched) {
                if (amountEl && !isEditing) amountEl.textContent = formatDec(shownDec);
                if (depositInput && !isEditing) depositInput.value = formatDec(shownDec);
              }
            }
            // Ê†πÊçÆ‰ΩôÈ¢ùÁä∂ÊÄÅÊõ¥Êñ∞ MAX ÊåâÈíÆÂèØÁî®ÊÄß
            updateMaxDisabled();
          } else {
            setDotState('step-approve-dot','error');
            setStepsError(data.error || 'Approve stage failed');
          }
        } catch(e){
          setDotState('step-approve-dot','error');
          setStepsError('Failed to read balance and approve');
        }
      }

      // Refresh approve and balance when account selection changes
      (function bindSelectRefresh(){
        const sel = document.getElementById('balance-index-select');
        if (!sel) return;
        const origOnChange = sel.onchange;
        sel.onchange = (ev)=>{
          if (typeof origOnChange === 'function') origOnChange(ev);
          // ÂàáÊç¢Ë¥¶Êà∑Êó∂ËØªÂèñËØ•Ë¥¶Êà∑ÁöÑÊú¨Âú∞‰º∞ÂÄº
          readPrivateEstimate();
          updateApproveAndBalance();
          updateMaxDisabled();
        };
      })();

      // ËµÑ‰∫ßÂàáÊç¢ÔºõÂΩìÂâçÂêéÁ´Ø‰ªÖÊîØÊåÅ RTÔºåETH ‰Ωú‰∏∫Âç†‰Ωç
      (function bindAssetSelect(){
        const assetSel = document.getElementById('asset-select');
        if (!assetSel) return;
        const unitEl = document.getElementById('deposit-unit');
        assetSel.addEventListener('change', ()=>{
          if (unitEl) unitEl.textContent = assetSel.value;
          // ÂàáÊç¢ÂêéÈáçÊñ∞ÂêåÊ≠•‰ΩôÈ¢ùÊòæÁ§∫
          updateApproveAndBalance();
        });
      })();

      // Bind unified CTA: call Deposit+Encrypt or Decrypt based on segment
      (function bindUnifiedCTA(){
        const cta = document.getElementById('btn-encrypt-cta');
        if (!cta) return;
        cta.onclick = async () => {
          const out = document.getElementById('mint-output');
          const rawInput = document.getElementById('deposit-input')?.value.trim() || '0';
          const sel = document.getElementById('balance-index-select');
          const idxVal = sel ? sel.value : '';
          const fromIndex = idxVal === '' ? '0' : idxVal;
          const encryptDot = document.getElementById('step-encrypt-dot');
          const isDecrypt = document.getElementById('tab-decrypt')?.classList.contains('active');

          if (isDecrypt) {
            // Decrypt mode: call /api/decrypt
            out.textContent = 'Submitting decrypt...';
            if (encryptDot) {
              encryptDot.classList.remove('done','error');
              encryptDot.classList.add('active');
            }
            try {
              const dec = sanitizeDecimalInput(rawInput);
              const numWei = toWei(dec);
              if (!(numWei > 0n)) {
                out.textContent = 'Error: Decrypt amount must be positive ETH';
                if (encryptDot) {
                  encryptDot.classList.remove('active');
                  encryptDot.classList.add('error');
                }
                return;
              }
              // Check uint128 limit (2^128 - 1 wei ‚âà 340 undecillion ETH - effectively unlimited for practical use)
              // We keep this check for safety, but it's unlikely to ever be hit with real ETH amounts
              const UINT128_MAX = 340282366920938463463374607431768211455n;
              if (numWei > UINT128_MAX) {
                const maxEth = formatDec(toDecimal(String(UINT128_MAX)));
                out.textContent = `Error: Amount exceeds uint128 maximum. Maximum is ${maxEth} ETH per transaction`;
                if (encryptDot) {
                  encryptDot.classList.remove('active');
                  encryptDot.classList.add('error');
                }
                return;
              }
              const acc = window.__accounts || [];
              const idx = parseInt(fromIndex, 10);
              if (!Number.isInteger(idx) || idx < 0 || idx >= acc.length) {
                out.textContent = 'Error: Please select a valid transaction account index (dropdown)';
                if (encryptDot) {
                  encryptDot.classList.remove('active');
                  encryptDot.classList.add('error');
                }
                return;
              }
              const data = await callApi('/api/decrypt', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ value: String(numWei), fromIndex })
              });
              if (data.ok) {
                out.textContent = `Decrypt succeeded, tx: ${data.tx}\\n\\nOutput:\\n${data.raw}`;
                if (encryptDot) {
                  encryptDot.classList.remove('active','error');
                  encryptDot.classList.add('done');
                }
                // Update private balance estimate
                if (numWei > 0n) {
                  const currentBal = BigInt(window.__privateBalanceEstimate || '0');
                  window.__privateBalanceEstimate = String(currentBal > numWei ? currentBal - numWei : 0n);
                  writePrivateEstimate();
                }
                updateApproveAndBalance();
                updateMaxDisabled();
              } else {
                out.textContent = `Error: ${data.error}`;
                if (encryptDot) {
                  encryptDot.classList.remove('active','done');
                  encryptDot.classList.add('error');
                }
              }
            } catch (e) {
              out.textContent = 'Request failed';
              if (encryptDot) {
                encryptDot.classList.remove('active','done');
                encryptDot.classList.add('error');
              }
            }
          } else {
            // Encrypt mode: call new combined /api/deposit-and-encrypt
            out.textContent = 'Submitting encrypt...';
            if (encryptDot) {
              encryptDot.classList.remove('done','error');
              encryptDot.classList.add('active');
            }
            try {
              const dec = sanitizeDecimalInput(rawInput);
              const numWei = toWei(dec);
              if (!(numWei > 0n)) {
                out.textContent = 'Error: Encrypt amount must be positive ETH';
                if (encryptDot) {
                  encryptDot.classList.remove('active');
                  encryptDot.classList.add('error');
                }
                return;
              }
              // Check uint128 limit (2^128 - 1 wei ‚âà 340 undecillion ETH - effectively unlimited for practical use)
              // We keep this check for safety, but it's unlikely to ever be hit with real ETH amounts
              const UINT128_MAX = 340282366920938463463374607431768211455n;
              if (numWei > UINT128_MAX) {
                const maxEth = formatDec(toDecimal(String(UINT128_MAX)));
                out.textContent = `Error: Amount exceeds uint128 maximum. Maximum is ${maxEth} ETH per transaction`;
                if (encryptDot) {
                  encryptDot.classList.remove('active');
                  encryptDot.classList.add('error');
                }
                return;
              }
              const acc = window.__accounts || [];
              const idx = parseInt(fromIndex, 10);
              if (!Number.isInteger(idx) || idx < 0 || idx >= acc.length) {
                out.textContent = 'Error: Please select a valid transaction account index (dropdown)';
                if (encryptDot) {
                  encryptDot.classList.remove('active');
                  encryptDot.classList.add('error');
                }
                return;
              }
              const data = await callApi('/api/deposit-and-encrypt', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ value: dec, fromIndex })
              });
              if (data.ok) {
                out.textContent = `Encrypt succeeded, tx: ${data.tx}\\n\\nOutput:\\n${data.raw}`;
                if (encryptDot) {
                  encryptDot.classList.remove('active','error');
                  encryptDot.classList.add('done');
                }
                // Update private balance estimate
                if (numWei > 0n) {
                  const currentBal = BigInt(window.__privateBalanceEstimate || '0');
                  window.__privateBalanceEstimate = String(currentBal + numWei);
                  writePrivateEstimate();
                }
                updateApproveAndBalance();
                updateMaxDisabled();
              } else {
                out.textContent = `Error: ${data.error}`;
                if (encryptDot) {
                  encryptDot.classList.remove('active','done');
                  encryptDot.classList.add('error');
                }
              }
            } catch (e) {
              out.textContent = 'Request failed';
              if (encryptDot) {
                encryptDot.classList.remove('active','done');
                encryptDot.classList.add('error');
              }
            }
          }
        };
      })();

      document.getElementById('btn-transfer').onclick = async () => {
        const out = document.getElementById('transfer-output');
        const to = document.getElementById('transfer-to').value.trim();
        const value = document.getElementById('transfer-value').value.trim();
        const sel = document.getElementById('balance-index-select');
        const idxVal = sel ? sel.value : '';
        const fromIndex = idxVal === '' ? '0' : idxVal;
        out.textContent = 'Submitting...';
        try {
          const encryptDot = document.getElementById('step-encrypt-dot');
          if (encryptDot) {
            encryptDot.classList.remove('done','error');
            encryptDot.classList.add('active');
          }
          // Frontend validation: address format, is local account, valid amount, index range
          if (!isValidAddress(to)) {
            out.textContent = 'Error: Invalid recipient address, please enter an Ethereum address like 0x...';
            return;
          }
          if (!isLocalAccount(to)) {
            out.textContent = 'Error: Recipient address not in local account list, may cause encryption verification failure. Please "Load Accounts" first and select a local account.';
            return;
          }
          const dec = sanitizeDecimalInput(value);
          const numWei = toWei(dec);
          if (!(numWei > 0n)) {
            out.textContent = 'Error: Amount must be positive ETH (e.g. 0.01)';
            return;
          }
          // Check uint128 limit (2^128 - 1 wei ‚âà 340 undecillion ETH - effectively unlimited for practical use)
          const UINT128_MAX = 340282366920938463463374607431768211455n;
          if (numWei > UINT128_MAX) {
            const maxEth = formatDec(toDecimal(String(UINT128_MAX)));
            out.textContent = `Error: Amount exceeds uint128 maximum. Maximum is ${maxEth} ETH per transaction`;
            return;
          }
          const acc = window.__accounts || [];
          const idx = parseInt(fromIndex, 10);
          if (!Number.isInteger(idx) || idx < 0 || idx >= acc.length) {
            out.textContent = 'Error: Please select a valid transaction account index (dropdown)';
            return;
          }
          const data = await callApi('/api/transfer', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ to, value: String(numWei), fromIndex })
          });
            if (data.ok) {
              const decimalShown = formatDec(toDecimal(String(numWei)));
              out.textContent = `Transfer succeeded, tx: ${data.tx}\n\nTransfer amount: ${decimalShown} ETH\nWei amount: ${String(numWei)}\nOutput:\n${data.raw}`;
              if (encryptDot) {
                encryptDot.classList.remove('active','error');
                encryptDot.classList.add('done');
              }
              // Estimate: deduct from local estimate when current selected account's private balance is transferred out
              const currentIdx = (document.getElementById('balance-index-select')?.value || '0');
              if (numWei > 0n && String(fromIndex) === String(currentIdx)) {
                const currentBal = BigInt(window.__privateBalanceEstimate || '0');
                window.__privateBalanceEstimate = String(currentBal > numWei ? currentBal - numWei : 0n);
                // Write to local persistence
                writePrivateEstimate();
                updateApproveAndBalance();
                updateMaxDisabled();
              }
            } else {
              out.textContent = `Error: ${data.error}`;
              if (encryptDot) {
                encryptDot.classList.remove('active','done');
              encryptDot.classList.add('error');
            }
          }
        } catch (e) {
          out.textContent = 'Request failed';
          const encryptDot = document.getElementById('step-encrypt-dot');
          if (encryptDot) {
            encryptDot.classList.remove('active','done');
            encryptDot.classList.add('error');
          }
        }
      };

      document.getElementById('btn-withdraw').onclick = async () => {
        const out = document.getElementById('withdraw-output');
        const value = document.getElementById('withdraw-value').value.trim();
        const sel = document.getElementById('balance-index-select');
        const idxVal = sel ? sel.value : '';
        const fromIndex = idxVal === '' ? '0' : idxVal;
        out.textContent = 'Submitting...';
        try {
          // Validate ETH amount
          const dec = sanitizeDecimalInput(value);
          const numWei = toWei(dec);
          if (!(numWei > 0n)) {
            out.textContent = 'Error: Amount must be positive ETH (e.g. 0.01)';
            return;
          }
          // Check uint128 limit (2^128 - 1 wei ‚âà 340 undecillion ETH - effectively unlimited for practical use)
          const UINT128_MAX = 340282366920938463463374607431768211455n;
          if (numWei > UINT128_MAX) {
            const maxEth = formatDec(toDecimal(String(UINT128_MAX)));
            out.textContent = `Error: Amount exceeds uint128 maximum. Maximum is ${maxEth} ETH per transaction`;
            return;
          }
          const acc = window.__accounts || [];
          const idx = parseInt(fromIndex, 10);
          if (!Number.isInteger(idx) || idx < 0 || idx >= acc.length) {
            out.textContent = 'Error: Please select a valid transaction account index (dropdown)';
            return;
          }
          const data = await callApi('/api/withdraw-eth', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ value: dec, fromIndex })
          });
          if (data.ok) {
            out.textContent = `ETH withdrawal succeeded, tx: ${data.tx}\n\nOutput:\n${data.raw}`;
            // Refresh balance after successful withdrawal
            try {
              await updateApproveAndBalance();
              updateMaxDisabled();
              // Reset withdraw input after successful withdrawal
              const withdrawValueEl = document.getElementById('withdraw-value');
              if (withdrawValueEl) withdrawValueEl.value = '0';
            } catch (e) { /* Ignore refresh errors, keep original message */ }
          } else {
            out.textContent = `Error: ${data.error}`;
          }
        } catch (e) {
          out.textContent = 'Request failed';
        }
      };
    </script>
  </body>
  </html>